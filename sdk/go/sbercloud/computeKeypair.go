// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sbercloud

import (
	"context"
	"reflect"

	"github.com/masikrus/pulumi-sbercloud/sdk/go/sbercloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ComputeKeypair struct {
	pulumi.CustomResourceState

	KeyFile   pulumi.StringOutput `pulumi:"keyFile"`
	Name      pulumi.StringOutput `pulumi:"name"`
	PublicKey pulumi.StringOutput `pulumi:"publicKey"`
	Region    pulumi.StringOutput `pulumi:"region"`
}

// NewComputeKeypair registers a new resource with the given unique name, arguments, and options.
func NewComputeKeypair(ctx *pulumi.Context,
	name string, args *ComputeKeypairArgs, opts ...pulumi.ResourceOption) (*ComputeKeypair, error) {
	if args == nil {
		args = &ComputeKeypairArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ComputeKeypair
	err := ctx.RegisterResource("sbercloud:index/computeKeypair:ComputeKeypair", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetComputeKeypair gets an existing ComputeKeypair resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetComputeKeypair(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ComputeKeypairState, opts ...pulumi.ResourceOption) (*ComputeKeypair, error) {
	var resource ComputeKeypair
	err := ctx.ReadResource("sbercloud:index/computeKeypair:ComputeKeypair", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ComputeKeypair resources.
type computeKeypairState struct {
	KeyFile   *string `pulumi:"keyFile"`
	Name      *string `pulumi:"name"`
	PublicKey *string `pulumi:"publicKey"`
	Region    *string `pulumi:"region"`
}

type ComputeKeypairState struct {
	KeyFile   pulumi.StringPtrInput
	Name      pulumi.StringPtrInput
	PublicKey pulumi.StringPtrInput
	Region    pulumi.StringPtrInput
}

func (ComputeKeypairState) ElementType() reflect.Type {
	return reflect.TypeOf((*computeKeypairState)(nil)).Elem()
}

type computeKeypairArgs struct {
	KeyFile   *string `pulumi:"keyFile"`
	Name      *string `pulumi:"name"`
	PublicKey *string `pulumi:"publicKey"`
	Region    *string `pulumi:"region"`
}

// The set of arguments for constructing a ComputeKeypair resource.
type ComputeKeypairArgs struct {
	KeyFile   pulumi.StringPtrInput
	Name      pulumi.StringPtrInput
	PublicKey pulumi.StringPtrInput
	Region    pulumi.StringPtrInput
}

func (ComputeKeypairArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*computeKeypairArgs)(nil)).Elem()
}

type ComputeKeypairInput interface {
	pulumi.Input

	ToComputeKeypairOutput() ComputeKeypairOutput
	ToComputeKeypairOutputWithContext(ctx context.Context) ComputeKeypairOutput
}

func (*ComputeKeypair) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeKeypair)(nil)).Elem()
}

func (i *ComputeKeypair) ToComputeKeypairOutput() ComputeKeypairOutput {
	return i.ToComputeKeypairOutputWithContext(context.Background())
}

func (i *ComputeKeypair) ToComputeKeypairOutputWithContext(ctx context.Context) ComputeKeypairOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeKeypairOutput)
}

// ComputeKeypairArrayInput is an input type that accepts ComputeKeypairArray and ComputeKeypairArrayOutput values.
// You can construct a concrete instance of `ComputeKeypairArrayInput` via:
//
//	ComputeKeypairArray{ ComputeKeypairArgs{...} }
type ComputeKeypairArrayInput interface {
	pulumi.Input

	ToComputeKeypairArrayOutput() ComputeKeypairArrayOutput
	ToComputeKeypairArrayOutputWithContext(context.Context) ComputeKeypairArrayOutput
}

type ComputeKeypairArray []ComputeKeypairInput

func (ComputeKeypairArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ComputeKeypair)(nil)).Elem()
}

func (i ComputeKeypairArray) ToComputeKeypairArrayOutput() ComputeKeypairArrayOutput {
	return i.ToComputeKeypairArrayOutputWithContext(context.Background())
}

func (i ComputeKeypairArray) ToComputeKeypairArrayOutputWithContext(ctx context.Context) ComputeKeypairArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeKeypairArrayOutput)
}

// ComputeKeypairMapInput is an input type that accepts ComputeKeypairMap and ComputeKeypairMapOutput values.
// You can construct a concrete instance of `ComputeKeypairMapInput` via:
//
//	ComputeKeypairMap{ "key": ComputeKeypairArgs{...} }
type ComputeKeypairMapInput interface {
	pulumi.Input

	ToComputeKeypairMapOutput() ComputeKeypairMapOutput
	ToComputeKeypairMapOutputWithContext(context.Context) ComputeKeypairMapOutput
}

type ComputeKeypairMap map[string]ComputeKeypairInput

func (ComputeKeypairMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ComputeKeypair)(nil)).Elem()
}

func (i ComputeKeypairMap) ToComputeKeypairMapOutput() ComputeKeypairMapOutput {
	return i.ToComputeKeypairMapOutputWithContext(context.Background())
}

func (i ComputeKeypairMap) ToComputeKeypairMapOutputWithContext(ctx context.Context) ComputeKeypairMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeKeypairMapOutput)
}

type ComputeKeypairOutput struct{ *pulumi.OutputState }

func (ComputeKeypairOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeKeypair)(nil)).Elem()
}

func (o ComputeKeypairOutput) ToComputeKeypairOutput() ComputeKeypairOutput {
	return o
}

func (o ComputeKeypairOutput) ToComputeKeypairOutputWithContext(ctx context.Context) ComputeKeypairOutput {
	return o
}

func (o ComputeKeypairOutput) KeyFile() pulumi.StringOutput {
	return o.ApplyT(func(v *ComputeKeypair) pulumi.StringOutput { return v.KeyFile }).(pulumi.StringOutput)
}

func (o ComputeKeypairOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ComputeKeypair) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ComputeKeypairOutput) PublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v *ComputeKeypair) pulumi.StringOutput { return v.PublicKey }).(pulumi.StringOutput)
}

func (o ComputeKeypairOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *ComputeKeypair) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

type ComputeKeypairArrayOutput struct{ *pulumi.OutputState }

func (ComputeKeypairArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ComputeKeypair)(nil)).Elem()
}

func (o ComputeKeypairArrayOutput) ToComputeKeypairArrayOutput() ComputeKeypairArrayOutput {
	return o
}

func (o ComputeKeypairArrayOutput) ToComputeKeypairArrayOutputWithContext(ctx context.Context) ComputeKeypairArrayOutput {
	return o
}

func (o ComputeKeypairArrayOutput) Index(i pulumi.IntInput) ComputeKeypairOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ComputeKeypair {
		return vs[0].([]*ComputeKeypair)[vs[1].(int)]
	}).(ComputeKeypairOutput)
}

type ComputeKeypairMapOutput struct{ *pulumi.OutputState }

func (ComputeKeypairMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ComputeKeypair)(nil)).Elem()
}

func (o ComputeKeypairMapOutput) ToComputeKeypairMapOutput() ComputeKeypairMapOutput {
	return o
}

func (o ComputeKeypairMapOutput) ToComputeKeypairMapOutputWithContext(ctx context.Context) ComputeKeypairMapOutput {
	return o
}

func (o ComputeKeypairMapOutput) MapIndex(k pulumi.StringInput) ComputeKeypairOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ComputeKeypair {
		return vs[0].(map[string]*ComputeKeypair)[vs[1].(string)]
	}).(ComputeKeypairOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ComputeKeypairInput)(nil)).Elem(), &ComputeKeypair{})
	pulumi.RegisterInputType(reflect.TypeOf((*ComputeKeypairArrayInput)(nil)).Elem(), ComputeKeypairArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ComputeKeypairMapInput)(nil)).Elem(), ComputeKeypairMap{})
	pulumi.RegisterOutputType(ComputeKeypairOutput{})
	pulumi.RegisterOutputType(ComputeKeypairArrayOutput{})
	pulumi.RegisterOutputType(ComputeKeypairMapOutput{})
}
