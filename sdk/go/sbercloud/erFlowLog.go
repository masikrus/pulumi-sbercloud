// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sbercloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/masikrus/pulumi-sbercloud/sdk/go/sbercloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ErFlowLog struct {
	pulumi.CustomResourceState

	CreatedAt    pulumi.StringOutput    `pulumi:"createdAt"`
	Description  pulumi.StringPtrOutput `pulumi:"description"`
	Enabled      pulumi.BoolPtrOutput   `pulumi:"enabled"`
	InstanceId   pulumi.StringOutput    `pulumi:"instanceId"`
	LogGroupId   pulumi.StringOutput    `pulumi:"logGroupId"`
	LogStoreType pulumi.StringOutput    `pulumi:"logStoreType"`
	LogStreamId  pulumi.StringOutput    `pulumi:"logStreamId"`
	Name         pulumi.StringOutput    `pulumi:"name"`
	Region       pulumi.StringOutput    `pulumi:"region"`
	ResourceId   pulumi.StringOutput    `pulumi:"resourceId"`
	ResourceType pulumi.StringOutput    `pulumi:"resourceType"`
	State        pulumi.StringOutput    `pulumi:"state"`
	UpdatedAt    pulumi.StringOutput    `pulumi:"updatedAt"`
}

// NewErFlowLog registers a new resource with the given unique name, arguments, and options.
func NewErFlowLog(ctx *pulumi.Context,
	name string, args *ErFlowLogArgs, opts ...pulumi.ResourceOption) (*ErFlowLog, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.LogGroupId == nil {
		return nil, errors.New("invalid value for required argument 'LogGroupId'")
	}
	if args.LogStoreType == nil {
		return nil, errors.New("invalid value for required argument 'LogStoreType'")
	}
	if args.LogStreamId == nil {
		return nil, errors.New("invalid value for required argument 'LogStreamId'")
	}
	if args.ResourceId == nil {
		return nil, errors.New("invalid value for required argument 'ResourceId'")
	}
	if args.ResourceType == nil {
		return nil, errors.New("invalid value for required argument 'ResourceType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ErFlowLog
	err := ctx.RegisterResource("sbercloud:index/erFlowLog:ErFlowLog", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetErFlowLog gets an existing ErFlowLog resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetErFlowLog(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ErFlowLogState, opts ...pulumi.ResourceOption) (*ErFlowLog, error) {
	var resource ErFlowLog
	err := ctx.ReadResource("sbercloud:index/erFlowLog:ErFlowLog", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ErFlowLog resources.
type erFlowLogState struct {
	CreatedAt    *string `pulumi:"createdAt"`
	Description  *string `pulumi:"description"`
	Enabled      *bool   `pulumi:"enabled"`
	InstanceId   *string `pulumi:"instanceId"`
	LogGroupId   *string `pulumi:"logGroupId"`
	LogStoreType *string `pulumi:"logStoreType"`
	LogStreamId  *string `pulumi:"logStreamId"`
	Name         *string `pulumi:"name"`
	Region       *string `pulumi:"region"`
	ResourceId   *string `pulumi:"resourceId"`
	ResourceType *string `pulumi:"resourceType"`
	State        *string `pulumi:"state"`
	UpdatedAt    *string `pulumi:"updatedAt"`
}

type ErFlowLogState struct {
	CreatedAt    pulumi.StringPtrInput
	Description  pulumi.StringPtrInput
	Enabled      pulumi.BoolPtrInput
	InstanceId   pulumi.StringPtrInput
	LogGroupId   pulumi.StringPtrInput
	LogStoreType pulumi.StringPtrInput
	LogStreamId  pulumi.StringPtrInput
	Name         pulumi.StringPtrInput
	Region       pulumi.StringPtrInput
	ResourceId   pulumi.StringPtrInput
	ResourceType pulumi.StringPtrInput
	State        pulumi.StringPtrInput
	UpdatedAt    pulumi.StringPtrInput
}

func (ErFlowLogState) ElementType() reflect.Type {
	return reflect.TypeOf((*erFlowLogState)(nil)).Elem()
}

type erFlowLogArgs struct {
	Description  *string `pulumi:"description"`
	Enabled      *bool   `pulumi:"enabled"`
	InstanceId   string  `pulumi:"instanceId"`
	LogGroupId   string  `pulumi:"logGroupId"`
	LogStoreType string  `pulumi:"logStoreType"`
	LogStreamId  string  `pulumi:"logStreamId"`
	Name         *string `pulumi:"name"`
	Region       *string `pulumi:"region"`
	ResourceId   string  `pulumi:"resourceId"`
	ResourceType string  `pulumi:"resourceType"`
}

// The set of arguments for constructing a ErFlowLog resource.
type ErFlowLogArgs struct {
	Description  pulumi.StringPtrInput
	Enabled      pulumi.BoolPtrInput
	InstanceId   pulumi.StringInput
	LogGroupId   pulumi.StringInput
	LogStoreType pulumi.StringInput
	LogStreamId  pulumi.StringInput
	Name         pulumi.StringPtrInput
	Region       pulumi.StringPtrInput
	ResourceId   pulumi.StringInput
	ResourceType pulumi.StringInput
}

func (ErFlowLogArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*erFlowLogArgs)(nil)).Elem()
}

type ErFlowLogInput interface {
	pulumi.Input

	ToErFlowLogOutput() ErFlowLogOutput
	ToErFlowLogOutputWithContext(ctx context.Context) ErFlowLogOutput
}

func (*ErFlowLog) ElementType() reflect.Type {
	return reflect.TypeOf((**ErFlowLog)(nil)).Elem()
}

func (i *ErFlowLog) ToErFlowLogOutput() ErFlowLogOutput {
	return i.ToErFlowLogOutputWithContext(context.Background())
}

func (i *ErFlowLog) ToErFlowLogOutputWithContext(ctx context.Context) ErFlowLogOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ErFlowLogOutput)
}

// ErFlowLogArrayInput is an input type that accepts ErFlowLogArray and ErFlowLogArrayOutput values.
// You can construct a concrete instance of `ErFlowLogArrayInput` via:
//
//	ErFlowLogArray{ ErFlowLogArgs{...} }
type ErFlowLogArrayInput interface {
	pulumi.Input

	ToErFlowLogArrayOutput() ErFlowLogArrayOutput
	ToErFlowLogArrayOutputWithContext(context.Context) ErFlowLogArrayOutput
}

type ErFlowLogArray []ErFlowLogInput

func (ErFlowLogArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ErFlowLog)(nil)).Elem()
}

func (i ErFlowLogArray) ToErFlowLogArrayOutput() ErFlowLogArrayOutput {
	return i.ToErFlowLogArrayOutputWithContext(context.Background())
}

func (i ErFlowLogArray) ToErFlowLogArrayOutputWithContext(ctx context.Context) ErFlowLogArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ErFlowLogArrayOutput)
}

// ErFlowLogMapInput is an input type that accepts ErFlowLogMap and ErFlowLogMapOutput values.
// You can construct a concrete instance of `ErFlowLogMapInput` via:
//
//	ErFlowLogMap{ "key": ErFlowLogArgs{...} }
type ErFlowLogMapInput interface {
	pulumi.Input

	ToErFlowLogMapOutput() ErFlowLogMapOutput
	ToErFlowLogMapOutputWithContext(context.Context) ErFlowLogMapOutput
}

type ErFlowLogMap map[string]ErFlowLogInput

func (ErFlowLogMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ErFlowLog)(nil)).Elem()
}

func (i ErFlowLogMap) ToErFlowLogMapOutput() ErFlowLogMapOutput {
	return i.ToErFlowLogMapOutputWithContext(context.Background())
}

func (i ErFlowLogMap) ToErFlowLogMapOutputWithContext(ctx context.Context) ErFlowLogMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ErFlowLogMapOutput)
}

type ErFlowLogOutput struct{ *pulumi.OutputState }

func (ErFlowLogOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ErFlowLog)(nil)).Elem()
}

func (o ErFlowLogOutput) ToErFlowLogOutput() ErFlowLogOutput {
	return o
}

func (o ErFlowLogOutput) ToErFlowLogOutputWithContext(ctx context.Context) ErFlowLogOutput {
	return o
}

func (o ErFlowLogOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o ErFlowLogOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

func (o ErFlowLogOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) LogGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.LogGroupId }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) LogStoreType() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.LogStoreType }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) LogStreamId() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.LogStreamId }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) ResourceId() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.ResourceId }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) ResourceType() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.ResourceType }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

func (o ErFlowLogOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ErFlowLog) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

type ErFlowLogArrayOutput struct{ *pulumi.OutputState }

func (ErFlowLogArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ErFlowLog)(nil)).Elem()
}

func (o ErFlowLogArrayOutput) ToErFlowLogArrayOutput() ErFlowLogArrayOutput {
	return o
}

func (o ErFlowLogArrayOutput) ToErFlowLogArrayOutputWithContext(ctx context.Context) ErFlowLogArrayOutput {
	return o
}

func (o ErFlowLogArrayOutput) Index(i pulumi.IntInput) ErFlowLogOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ErFlowLog {
		return vs[0].([]*ErFlowLog)[vs[1].(int)]
	}).(ErFlowLogOutput)
}

type ErFlowLogMapOutput struct{ *pulumi.OutputState }

func (ErFlowLogMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ErFlowLog)(nil)).Elem()
}

func (o ErFlowLogMapOutput) ToErFlowLogMapOutput() ErFlowLogMapOutput {
	return o
}

func (o ErFlowLogMapOutput) ToErFlowLogMapOutputWithContext(ctx context.Context) ErFlowLogMapOutput {
	return o
}

func (o ErFlowLogMapOutput) MapIndex(k pulumi.StringInput) ErFlowLogOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ErFlowLog {
		return vs[0].(map[string]*ErFlowLog)[vs[1].(string)]
	}).(ErFlowLogOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ErFlowLogInput)(nil)).Elem(), &ErFlowLog{})
	pulumi.RegisterInputType(reflect.TypeOf((*ErFlowLogArrayInput)(nil)).Elem(), ErFlowLogArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ErFlowLogMapInput)(nil)).Elem(), ErFlowLogMap{})
	pulumi.RegisterOutputType(ErFlowLogOutput{})
	pulumi.RegisterOutputType(ErFlowLogArrayOutput{})
	pulumi.RegisterOutputType(ErFlowLogMapOutput{})
}
