// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AomServiceDiscoveryRuleDiscoveryRule {
    checkContents: string[];
    checkMode: string;
    checkType: string;
}

export interface AomServiceDiscoveryRuleLogPathRule {
    args: string[];
    nameType: string;
    values: string[];
}

export interface AomServiceDiscoveryRuleNameRules {
    applicationNameRules: outputs.AomServiceDiscoveryRuleNameRulesApplicationNameRule[];
    serviceNameRules: outputs.AomServiceDiscoveryRuleNameRulesServiceNameRule[];
}

export interface AomServiceDiscoveryRuleNameRulesApplicationNameRule {
    args: string[];
    nameType: string;
    values?: string[];
}

export interface AomServiceDiscoveryRuleNameRulesServiceNameRule {
    args: string[];
    nameType: string;
    values?: string[];
}

export interface ApiGatewayApiBackendParam {
    /**
     * The description of the parameter.
     */
    description?: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The parameter name.
     */
    name: string;
    systemParamType?: string;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * The value of the parameter
     */
    value: string;
}

export interface ApiGatewayApiFuncGraph {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn?: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The invocation type.
     */
    invocationType?: string;
    /**
     * The network architecture (framework) type of the FunctionGraph function.
     */
    networkType?: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol?: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout?: number;
    /**
     * The version of the FunctionGraph function.
     */
    version?: string;
}

export interface ApiGatewayApiFuncGraphPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The configaiton list of the backend parameters.
     */
    backendParams?: outputs.ApiGatewayApiFuncGraphPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.ApiGatewayApiFuncGraphPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode?: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn?: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The invocation mode of the FunctionGraph function.
     */
    invocationMode?: string;
    /**
     * The invocation mode of the FunctionGraph function.
     */
    invocationType?: string;
    /**
     * The name of the backend policy.
     */
    name: string;
    /**
     * The network (framework) type of the FunctionGraph function.
     */
    networkType?: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol?: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout?: number;
    /**
     * The version of the FunctionGraph function.
     */
    version?: string;
}

export interface ApiGatewayApiFuncGraphPolicyBackendParam {
    /**
     * The description of the parameter.
     */
    description?: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The parameter name.
     */
    name: string;
    systemParamType?: string;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * The value of the parameter
     */
    value: string;
}

export interface ApiGatewayApiFuncGraphPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName?: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName?: string;
    /**
     * The location of a parameter generated after orchestration.
     */
    mappedParamLocation?: string;
    /**
     * The name of a parameter generated after orchestration.
     */
    mappedParamName?: string;
    /**
     * The request parameter name.
     */
    paramName?: string;
    /**
     * The type of the backend policy.
     */
    source?: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName?: string;
    /**
     * The condition type.
     */
    type?: string;
    /**
     * The value of the backend policy.
     */
    value: string;
}

export interface ApiGatewayApiMock {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The response content of the mock.
     */
    response?: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface ApiGatewayApiMockPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The configuration list of backend parameters.
     */
    backendParams?: outputs.ApiGatewayApiMockPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.ApiGatewayApiMockPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode?: string;
    /**
     * The backend policy name.
     */
    name: string;
    /**
     * The response content of the mock.
     */
    response?: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface ApiGatewayApiMockPolicyBackendParam {
    /**
     * The description of the parameter.
     */
    description?: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The parameter name.
     */
    name: string;
    systemParamType?: string;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * The value of the parameter
     */
    value: string;
}

export interface ApiGatewayApiMockPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName?: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName?: string;
    /**
     * The location of a parameter generated after orchestration.
     */
    mappedParamLocation?: string;
    /**
     * The name of a parameter generated after orchestration.
     */
    mappedParamName?: string;
    /**
     * The request parameter name.
     */
    paramName?: string;
    /**
     * The type of the backend policy.
     */
    source?: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName?: string;
    /**
     * The condition type.
     */
    type?: string;
    /**
     * The value of the backend policy.
     */
    value: string;
}

export interface ApiGatewayApiRequestParam {
    /**
     * The default value of the parameter.
     */
    default: string;
    /**
     * The parameter description.
     */
    description: string;
    /**
     * The enumerated value.
     */
    enumeration: string;
    /**
     * The parameter example.
     */
    example: string;
    /**
     * Where this parameter is located.
     */
    location?: string;
    /**
     * The maximum value or length (string parameter) for parameter.
     */
    maximum: number;
    /**
     * The minimum value or length (string parameter) for parameter.
     */
    minimum: number;
    /**
     * The name of the request parameter.
     */
    name: string;
    /**
     * The list of orchestration rules that parameter used.
     */
    orchestrations?: string[];
    /**
     * Whether to transparently transfer the parameter.
     */
    passthrough: boolean;
    /**
     * Whether this parameter is required.
     */
    required: boolean;
    /**
     * The parameter type.
     */
    type?: string;
    /**
     * Whether to enable the parameter validation.
     */
    validEnable: number;
}

export interface ApiGatewayApiWeb {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The backend service address, which consists of a domain name or IP address, and a port number.
     */
    backendAddress?: string;
    /**
     * The proxy host header.
     */
    hostHeader?: string;
    /**
     * The backend request path.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod?: string;
    /**
     * The web protocol type of the API request.
     */
    requestProtocol?: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount?: number;
    /**
     * Whether to enable two-way authentication.
     */
    sslEnable?: boolean;
    /**
     * The timeout for API requests to backend service.
     */
    timeout?: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId?: string;
}

export interface ApiGatewayApiWebPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The backend service address
     */
    backendAddress?: string;
    /**
     * The configuration list of the backend parameters.
     */
    backendParams?: outputs.ApiGatewayApiWebPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.ApiGatewayApiWebPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode?: string;
    /**
     * The proxy host header.
     */
    hostHeader?: string;
    /**
     * The name of the web policy.
     */
    name: string;
    /**
     * The backend request address.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod: string;
    /**
     * The backend request protocol.
     */
    requestProtocol?: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount?: number;
    /**
     * The timeout for API requests to backend service.
     */
    timeout?: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId?: string;
}

export interface ApiGatewayApiWebPolicyBackendParam {
    /**
     * The description of the parameter.
     */
    description?: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The parameter name.
     */
    name: string;
    systemParamType?: string;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * The value of the parameter
     */
    value: string;
}

export interface ApiGatewayApiWebPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName?: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName?: string;
    /**
     * The location of a parameter generated after orchestration.
     */
    mappedParamLocation?: string;
    /**
     * The name of a parameter generated after orchestration.
     */
    mappedParamName?: string;
    /**
     * The request parameter name.
     */
    paramName?: string;
    /**
     * The type of the backend policy.
     */
    source?: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName?: string;
    /**
     * The condition type.
     */
    type?: string;
    /**
     * The value of the backend policy.
     */
    value: string;
}

export interface ApiGatewayGroupEnvironment {
    /**
     * The ID of the environment to which the variables belongs.
     */
    environmentId: string;
    /**
     * The array of one or more environment variables.
     */
    variables: outputs.ApiGatewayGroupEnvironmentVariable[];
}

export interface ApiGatewayGroupEnvironmentVariable {
    /**
     * The ID of the variable that the group has.
     */
    id: string;
    /**
     * The variable name.
     */
    name: string;
    /**
     * The variable value.
     */
    value: string;
    /**
     * schema: Deprecated; The ID of the variable that the group has.
     *
     * @deprecated Use 'id' instead
     */
    variableId: string;
}

export interface ApiGatewayGroupUrlDomain {
    /**
     * Whether to enable redirection from HTTP to HTTPS.
     */
    isHttpRedirectToHttps: boolean;
    /**
     * The minimum SSL protocol version.
     */
    minSslVersion: string;
    /**
     * The associated domain name.
     */
    name: string;
}

export interface ApigApiBackendParam {
    /**
     * The description of the parameter.
     */
    description?: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The parameter name.
     */
    name: string;
    systemParamType?: string;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * The value of the parameter
     */
    value: string;
}

export interface ApigApiFuncGraph {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn?: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The invocation type.
     */
    invocationType?: string;
    /**
     * The network architecture (framework) type of the FunctionGraph function.
     */
    networkType?: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol?: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout?: number;
    /**
     * The version of the FunctionGraph function.
     */
    version?: string;
}

export interface ApigApiFuncGraphPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The configaiton list of the backend parameters.
     */
    backendParams?: outputs.ApigApiFuncGraphPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.ApigApiFuncGraphPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode?: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn?: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The invocation mode of the FunctionGraph function.
     */
    invocationMode?: string;
    /**
     * The invocation mode of the FunctionGraph function.
     */
    invocationType?: string;
    /**
     * The name of the backend policy.
     */
    name: string;
    /**
     * The network (framework) type of the FunctionGraph function.
     */
    networkType?: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol?: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout?: number;
    /**
     * The version of the FunctionGraph function.
     */
    version?: string;
}

export interface ApigApiFuncGraphPolicyBackendParam {
    /**
     * The description of the parameter.
     */
    description?: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The parameter name.
     */
    name: string;
    systemParamType?: string;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * The value of the parameter
     */
    value: string;
}

export interface ApigApiFuncGraphPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName?: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName?: string;
    /**
     * The location of a parameter generated after orchestration.
     */
    mappedParamLocation?: string;
    /**
     * The name of a parameter generated after orchestration.
     */
    mappedParamName?: string;
    /**
     * The request parameter name.
     */
    paramName?: string;
    /**
     * The type of the backend policy.
     */
    source?: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName?: string;
    /**
     * The condition type.
     */
    type?: string;
    /**
     * The value of the backend policy.
     */
    value: string;
}

export interface ApigApiMock {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The response content of the mock.
     */
    response?: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface ApigApiMockPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The configuration list of backend parameters.
     */
    backendParams?: outputs.ApigApiMockPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.ApigApiMockPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode?: string;
    /**
     * The backend policy name.
     */
    name: string;
    /**
     * The response content of the mock.
     */
    response?: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface ApigApiMockPolicyBackendParam {
    /**
     * The description of the parameter.
     */
    description?: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The parameter name.
     */
    name: string;
    systemParamType?: string;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * The value of the parameter
     */
    value: string;
}

export interface ApigApiMockPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName?: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName?: string;
    /**
     * The location of a parameter generated after orchestration.
     */
    mappedParamLocation?: string;
    /**
     * The name of a parameter generated after orchestration.
     */
    mappedParamName?: string;
    /**
     * The request parameter name.
     */
    paramName?: string;
    /**
     * The type of the backend policy.
     */
    source?: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName?: string;
    /**
     * The condition type.
     */
    type?: string;
    /**
     * The value of the backend policy.
     */
    value: string;
}

export interface ApigApiPublishmentHistory {
    /**
     * The version description of the API publishment.
     */
    description: string;
    /**
     * The version ID of the API publishment.
     */
    versionId: string;
}

export interface ApigApiRequestParam {
    /**
     * The default value of the parameter.
     */
    default: string;
    /**
     * The parameter description.
     */
    description: string;
    /**
     * The enumerated value.
     */
    enumeration: string;
    /**
     * The parameter example.
     */
    example: string;
    /**
     * Where this parameter is located.
     */
    location?: string;
    /**
     * The maximum value or length (string parameter) for parameter.
     */
    maximum: number;
    /**
     * The minimum value or length (string parameter) for parameter.
     */
    minimum: number;
    /**
     * The name of the request parameter.
     */
    name: string;
    /**
     * The list of orchestration rules that parameter used.
     */
    orchestrations?: string[];
    /**
     * Whether to transparently transfer the parameter.
     */
    passthrough: boolean;
    /**
     * Whether this parameter is required.
     */
    required: boolean;
    /**
     * The parameter type.
     */
    type?: string;
    /**
     * Whether to enable the parameter validation.
     */
    validEnable: number;
}

export interface ApigApiWeb {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The backend service address, which consists of a domain name or IP address, and a port number.
     */
    backendAddress?: string;
    /**
     * The proxy host header.
     */
    hostHeader?: string;
    /**
     * The backend request path.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod?: string;
    /**
     * The web protocol type of the API request.
     */
    requestProtocol?: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount?: number;
    /**
     * Whether to enable two-way authentication.
     */
    sslEnable?: boolean;
    /**
     * The timeout for API requests to backend service.
     */
    timeout?: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId?: string;
}

export interface ApigApiWebPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId?: string;
    /**
     * The backend service address
     */
    backendAddress?: string;
    /**
     * The configuration list of the backend parameters.
     */
    backendParams?: outputs.ApigApiWebPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.ApigApiWebPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode?: string;
    /**
     * The proxy host header.
     */
    hostHeader?: string;
    /**
     * The name of the web policy.
     */
    name: string;
    /**
     * The backend request address.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod: string;
    /**
     * The backend request protocol.
     */
    requestProtocol?: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount?: number;
    /**
     * The timeout for API requests to backend service.
     */
    timeout?: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId?: string;
}

export interface ApigApiWebPolicyBackendParam {
    /**
     * The description of the parameter.
     */
    description?: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The parameter name.
     */
    name: string;
    systemParamType?: string;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * The value of the parameter
     */
    value: string;
}

export interface ApigApiWebPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName?: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName?: string;
    /**
     * The location of a parameter generated after orchestration.
     */
    mappedParamLocation?: string;
    /**
     * The name of a parameter generated after orchestration.
     */
    mappedParamName?: string;
    /**
     * The request parameter name.
     */
    paramName?: string;
    /**
     * The type of the backend policy.
     */
    source?: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName?: string;
    /**
     * The condition type.
     */
    type?: string;
    /**
     * The value of the backend policy.
     */
    value: string;
}

export interface ApigApplicationQuotaAssociateApplication {
    /**
     * The binding time, in RFC3339 format.
     */
    bindTime: string;
    /**
     * The application ID bound to the application quota.
     */
    id: string;
}

export interface ApigChannelHealthCheck {
    /**
     * Whether to enable two-way authentication.
     */
    enableClientSsl: boolean;
    /**
     * The response codes for determining a successful HTTP response.
     */
    httpCodes: string;
    /**
     * The interval between consecutive check, in second.
     */
    interval: number;
    /**
     * The request method for health check.
     */
    method: string;
    /**
     * The destination path for health check.
     */
    path: string;
    /**
     * The destination host port for health check.
     */
    port: number;
    /**
     * The rotocol for performing health check on backend servers.
     */
    protocol: string;
    /**
     * The status of health check.
     */
    status: number;
    /**
     * The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
     */
    thresholdAbnormal: number;
    /**
     * The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
     */
    thresholdNormal: number;
    /**
     * The timeout for determining whether a health check fails, in second.
     */
    timeout: number;
}

export interface ApigChannelMember {
    /**
     * The group name of the backend server.
     */
    groupName: string;
    /**
     * The IP address of the backend server.
     */
    host: string;
    /**
     * The ID of the backend server.
     */
    id: string;
    /**
     * Whether this member is the backup member.
     */
    isBackup: boolean;
    /**
     * The name of the backend server.
     */
    name: string;
    /**
     * The port of the backend server.
     */
    port: number;
    /**
     * The status of the backend server.
     */
    status: number;
    /**
     * The weight of current backend server.
     */
    weight: number;
}

export interface ApigChannelMemberGroup {
    /**
     * The description of the member group.
     */
    description: string;
    /**
     * The microservice tags of the backend server group.
     */
    microserviceLabels: {[key: string]: string};
    /**
     * The microservice port of the backend server group.
     */
    microservicePort: number;
    /**
     * The microservice version of the backend server group.
     */
    microserviceVersion: string;
    /**
     * The name of the member group.
     */
    name: string;
    /**
     * The ID of the reference load balance channel.
     */
    referenceVpcChannelId: string;
    /**
     * The weight of the current member group.
     */
    weight: number;
}

export interface ApigChannelMicroservice {
    /**
     * The CCE microservice details.
     */
    cceConfig: outputs.ApigChannelMicroserviceCceConfig;
    /**
     * schema:Internal; The CSE microservice details.
     */
    cseConfig: outputs.ApigChannelMicroserviceCseConfig;
}

export interface ApigChannelMicroserviceCceConfig {
    /**
     * The ID of the CCE cluster.
     */
    clusterId: string;
    /**
     * The service label key.
     */
    labelKey?: string;
    /**
     * The service label value.
     */
    labelValue?: string;
    /**
     * The name of the CCE namespace.
     */
    namespace: string;
    /**
     * The workload name.
     */
    workloadName?: string;
    /**
     * The workload type.
     */
    workloadType: string;
}

export interface ApigChannelMicroserviceCseConfig {
    /**
     * schema:Internal; The microservice engine ID.
     */
    engineId: string;
    /**
     * schema:Internal; The microservice ID.
     */
    serviceId: string;
}

export interface ApigCustomAuthorizerIdentity {
    /**
     * The parameter location.
     */
    location: string;
    /**
     * The name of the parameter to be verified.
     */
    name: string;
    /**
     * The parameter verification expression.
     */
    validation?: string;
}

export interface ApigGroupEnvironment {
    /**
     * The ID of the environment to which the variables belongs.
     */
    environmentId: string;
    /**
     * The array of one or more environment variables.
     */
    variables: outputs.ApigGroupEnvironmentVariable[];
}

export interface ApigGroupEnvironmentVariable {
    /**
     * The ID of the variable that the group has.
     */
    id: string;
    /**
     * The variable name.
     */
    name: string;
    /**
     * The variable value.
     */
    value: string;
    /**
     * schema: Deprecated; The ID of the variable that the group has.
     *
     * @deprecated Use 'id' instead
     */
    variableId: string;
}

export interface ApigGroupUrlDomain {
    /**
     * Whether to enable redirection from HTTP to HTTPS.
     */
    isHttpRedirectToHttps: boolean;
    /**
     * The minimum SSL protocol version.
     */
    minSslVersion: string;
    /**
     * The associated domain name.
     */
    name: string;
}

export interface ApigInstanceCustomIngressPort {
    /**
     * The ID of the custom ingress port.
     */
    id: string;
    /**
     * Specified port of the custom ingress port.
     */
    port: number;
    /**
     * Specified protocol of the custom ingress port.
     */
    protocol: string;
    /**
     * The current status of the custom ingress port.
     */
    status: string;
}

export interface ApigResponseRule {
    /**
     * The body template of the API custom response rule.
     */
    body: string;
    /**
     * The error type of the API custom response rule.
     */
    errorType: string;
    /**
     * The configuration of the custom response headers.
     */
    headers?: outputs.ApigResponseRuleHeader[];
    /**
     * The HTTP status code of the API custom response rule.
     */
    statusCode: number;
}

export interface ApigResponseRuleHeader {
    /**
     * The key name of the response header.
     */
    key: string;
    /**
     * The value for the specified response header key.
     */
    value: string;
}

export interface ApigThrottlingPolicyAppThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface ApigThrottlingPolicyUserThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface AsBandwidthPolicyIntervalAlarmAction {
    /**
     * Specifies the operation restrictions.
     */
    limits: number;
    /**
     * Specifies the lower limit of the value range.
     */
    lowerBound: string;
    /**
     * Specifies the operation to be performed.
     */
    operation: string;
    /**
     * Specifies the operation size.
     */
    size: number;
    /**
     * Specifies the upper limit of the value range.
     */
    upperBound: string;
}

export interface AsBandwidthPolicyMetaData {
    /**
     * The bandwidth sharing type in the bandwidth policy.
     */
    metadataBandwidthShareType: string;
    /**
     * The EIP IP address for the bandwidth in the bandwidth policy.
     */
    metadataEipAddress: string;
    /**
     * The EIP ID for the bandwidth in the bandwidth policy.
     */
    metadataEipId: string;
}

export interface AsBandwidthPolicyScalingPolicyAction {
    /**
     * Specifies the operation restrictions.
     */
    limits: number;
    /**
     * Specifies the operation to be performed. The default operation is ADD.
     */
    operation: string;
    /**
     * Specifies the bandwidth (Mbit/s).
     */
    size: number;
}

export interface AsBandwidthPolicyScheduledPolicy {
    /**
     * Specifies the end time of the scaling action triggered periodically.
     */
    endTime: string;
    /**
     * Specifies the time when the scaling action is triggered. The time format complies with UTC.
     */
    launchTime: string;
    /**
     * Specifies the periodic triggering type.
     */
    recurrenceType: string;
    /**
     * Specifies the day when a periodic scaling action is triggered.
     */
    recurrenceValue: string;
    /**
     * Specifies the start time of the scaling action triggered periodically.
     */
    startTime: string;
}

export interface AsConfigurationInstanceConfig {
    adminPass?: string;
    chargingMode?: string;
    dedicatedHostId: string;
    disks: outputs.AsConfigurationInstanceConfigDisk[];
    ecsGroupId: string;
    flavor: string;
    flavorPriorityPolicy: string;
    image: string;
    instanceId: string;
    keyFingerprint: string;
    keyName: string;
    metadata?: {[key: string]: string};
    personalities: outputs.AsConfigurationInstanceConfigPersonality[];
    publicIp: outputs.AsConfigurationInstanceConfigPublicIp;
    /**
     * schema: Required
     */
    securityGroupIds: string[];
    tenancy: string;
    userData?: string;
}

export interface AsConfigurationInstanceConfigDisk {
    dataDiskImageId: string;
    dedicatedStorageId: string;
    diskType: string;
    iops: number;
    kmsId: string;
    size: number;
    snapshotId: string;
    throughput: number;
    volumeType: string;
}

export interface AsConfigurationInstanceConfigPersonality {
    content: string;
    path: string;
}

export interface AsConfigurationInstanceConfigPublicIp {
    eip: outputs.AsConfigurationInstanceConfigPublicIpEip;
}

export interface AsConfigurationInstanceConfigPublicIpEip {
    bandwidth: outputs.AsConfigurationInstanceConfigPublicIpEipBandwidth;
    ipType: string;
}

export interface AsConfigurationInstanceConfigPublicIpEipBandwidth {
    chargingMode: string;
    id: string;
    shareType: string;
    size: number;
}

export interface AsGroupLbaasListener {
    listenerId: string;
    poolId: string;
    protocolPort: number;
    protocolVersion: string;
    weight?: number;
}

export interface AsGroupNetwork {
    id: string;
    ipv6BandwidthId?: string;
    ipv6Enable?: boolean;
    sourceDestCheck?: boolean;
}

export interface AsGroupSecurityGroup {
    id: string;
}

export interface AsPolicyScalingPolicyAction {
    instanceNumber: number;
    instancePercentage?: number;
    operation: string;
}

export interface AsPolicyScheduledPolicy {
    endTime: string;
    launchTime: string;
    recurrenceType: string;
    recurrenceValue: string;
    startTime: string;
}

export interface CbrBackupShareMember {
    /**
     * The creation time of the backup shared member.
     */
    createdAt: string;
    /**
     * The ID of the project with which the backup is shared.
     */
    destProjectId: string;
    /**
     * The ID of the backup shared member record.
     */
    id: string;
    /**
     * The ID of the image registered with the shared backup copy.
     */
    imageId: string;
    /**
     * The backup shared status.
     */
    status: string;
    /**
     * The latest update time of the backup shared member.
     */
    updatedAt: string;
    /**
     * The ID of the vault where the shared backup is stored.
     */
    vaultId: string;
}

export interface CbrCheckpointBackup {
    /**
     * The backup ID.
     */
    id: string;
    /**
     * The backup time.
     */
    protectedAt: string;
    /**
     * The ID of backup resource.
     */
    resourceId: string;
    /**
     * The backup resource size.
     */
    resourceSize: number;
    /**
     * The backup status.
     */
    status: string;
    /**
     * The type of the backup resource.
     */
    type: string;
    /**
     * The latest update time of the backup.
     */
    updatedAt: string;
}

export interface CbrPolicyBackupCycle {
    /**
     * The weekly backup time.
     */
    days?: string;
    /**
     * The execution time of the policy.
     */
    executionTimes: string[];
    /**
     * The number of days between each backup.
     */
    interval?: number;
}

export interface CbrPolicyLongTermRetention {
    /**
     * The latest backup of each day is saved in the long term.
     */
    daily?: number;
    /**
     * How often (after how many incremental backups) a full backup is performed.
     */
    fullBackupInterval?: number;
    /**
     * The latest backup of each month is saved in the long term.
     */
    monthly?: number;
    /**
     * The latest backup of each week is saved in the long term.
     */
    weekly?: number;
    /**
     * The latest backup of each year is saved in the long term.
     */
    yearly?: number;
}

export interface CbrVaultPolicy {
    /**
     * The ID of destination vault to which the replication policy will associated.
     */
    destinationVaultId?: string;
    /**
     * The policy ID.
     */
    id: string;
}

export interface CbrVaultResource {
    /**
     * The array of disk IDs which will be excluded in the backup.
     */
    excludes: string[];
    /**
     * The array of disk or SFS file systems which will be included in the backup.
     */
    includes: string[];
    /**
     * The ID of the ECS instance to be backed up.
     */
    serverId?: string;
}

export interface CceAddonValues {
    basic?: {[key: string]: string};
    basicJson?: string;
    custom?: {[key: string]: string};
    customJson?: string;
    flavor?: {[key: string]: string};
    flavorJson?: string;
}

export interface CceClusterCertificateCluster {
    certificateAuthorityData: string;
    name: string;
    server: string;
}

export interface CceClusterCertificateUser {
    clientCertificateData: string;
    clientKeyData: string;
    name: string;
}

export interface CceClusterComponentConfiguration {
    configurations?: string;
    name: string;
}

export interface CceClusterEncryptionConfig {
    kmsKeyId: string;
    mode: string;
}

export interface CceClusterExtendParam {
    clusterAz?: string;
    cpuManagerPolicy?: string;
    decMasterFlavor?: string;
    dockerUmaskMode?: string;
    dssMasterVolumes?: string;
    fixPoolMask?: string;
}

export interface CceClusterMaster {
    availabilityZone: string;
}

export interface CceNodeAttachDataVolume {
    dssPoolId: string;
    /**
     * @deprecated use extendParams instead
     */
    extendParam: string;
    extendParams: {[key: string]: string};
    /**
     * schema: Internal
     */
    hwPassthrough: boolean;
    iops: number;
    kmsKeyId: string;
    size: number;
    throughput: number;
    volumetype: string;
}

export interface CceNodeAttachExtensionNic {
    subnetId: string;
}

export interface CceNodeAttachHostnameConfig {
    type: string;
}

export interface CceNodeAttachRootVolume {
    dssPoolId: string;
    /**
     * @deprecated use extendParams instead
     */
    extendParam: string;
    extendParams: {[key: string]: string};
    /**
     * schema: Internal
     */
    hwPassthrough: boolean;
    iops: number;
    kmsKeyId: string;
    size: number;
    throughput: number;
    volumetype: string;
}

export interface CceNodeAttachStorage {
    groups: outputs.CceNodeAttachStorageGroup[];
    selectors: outputs.CceNodeAttachStorageSelector[];
}

export interface CceNodeAttachStorageGroup {
    cceManaged?: boolean;
    name: string;
    selectorNames: string[];
    virtualSpaces: outputs.CceNodeAttachStorageGroupVirtualSpace[];
}

export interface CceNodeAttachStorageGroupVirtualSpace {
    lvmLvType?: string;
    lvmPath?: string;
    name: string;
    runtimeLvType?: string;
    size: string;
}

export interface CceNodeAttachStorageSelector {
    matchLabelCount?: string;
    matchLabelMetadataCmkid?: string;
    matchLabelMetadataEncrypted?: string;
    matchLabelSize?: string;
    matchLabelVolumeType?: string;
    name: string;
    type?: string;
}

export interface CceNodeAttachTaint {
    effect: string;
    key: string;
    value: string;
}

export interface CceNodeDataVolume {
    dssPoolId: string;
    /**
     * @deprecated use extendParams instead
     */
    extendParam?: string;
    extendParams: {[key: string]: string};
    /**
     * schema: Internal
     */
    hwPassthrough: boolean;
    iops: number;
    kmsKeyId: string;
    size: number;
    throughput: number;
    volumetype: string;
}

export interface CceNodeExtendParams {
    agencyName?: string;
    dockerBaseSize?: number;
    kubeReservedMem?: number;
    marketType?: string;
    maxPods?: number;
    nicThreshold?: string;
    nodeImageId?: string;
    nodeMultiQueue?: string;
    postinstall?: string;
    preinstall?: string;
    securityReinforcementType?: string;
    spotPrice?: string;
    systemReservedMem?: number;
}

export interface CceNodeExtensionNic {
    subnetId: string;
}

export interface CceNodeHostnameConfig {
    type: string;
}

export interface CceNodePoolDataVolume {
    dssPoolId: string;
    /**
     * @deprecated use extendParams instead
     */
    extendParam?: string;
    extendParams: {[key: string]: string};
    /**
     * schema: Internal
     */
    hwPassthrough: boolean;
    iops: number;
    kmsKeyId: string;
    size: number;
    throughput: number;
    volumetype: string;
}

export interface CceNodePoolExtendParams {
    agencyName: string;
    dockerBaseSize: number;
    kubeReservedMem: number;
    marketType: string;
    maxPods: number;
    nicThreshold: string;
    nodeImageId: string;
    nodeMultiQueue: string;
    postinstall: string;
    preinstall: string;
    securityReinforcementType: string;
    spotPrice: string;
    systemReservedMem: number;
}

export interface CceNodePoolExtensionScaleGroup {
    metadata?: outputs.CceNodePoolExtensionScaleGroupMetadata;
    spec?: outputs.CceNodePoolExtensionScaleGroupSpec;
}

export interface CceNodePoolExtensionScaleGroupMetadata {
    name?: string;
}

export interface CceNodePoolExtensionScaleGroupSpec {
    autoscaling?: outputs.CceNodePoolExtensionScaleGroupSpecAutoscaling;
    az?: string;
    capacityReservationSpecification?: outputs.CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecification;
    flavor?: string;
}

export interface CceNodePoolExtensionScaleGroupSpecAutoscaling {
    enable?: boolean;
    extensionPriority?: number;
    maxNodeCount?: number;
    minNodeCount?: number;
}

export interface CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecification {
    id?: string;
    preference?: string;
}

export interface CceNodePoolHostnameConfig {
    type: string;
}

export interface CceNodePoolRootVolume {
    dssPoolId: string;
    /**
     * @deprecated use extendParams instead
     */
    extendParam?: string;
    extendParams: {[key: string]: string};
    /**
     * schema: Internal
     */
    hwPassthrough: boolean;
    iops: number;
    kmsKeyId: string;
    size: number;
    throughput: number;
    volumetype: string;
}

export interface CceNodePoolStorage {
    groups: outputs.CceNodePoolStorageGroup[];
    selectors: outputs.CceNodePoolStorageSelector[];
}

export interface CceNodePoolStorageGroup {
    cceManaged?: boolean;
    name: string;
    selectorNames: string[];
    virtualSpaces: outputs.CceNodePoolStorageGroupVirtualSpace[];
}

export interface CceNodePoolStorageGroupVirtualSpace {
    lvmLvType?: string;
    lvmPath?: string;
    name: string;
    runtimeLvType?: string;
    size: string;
}

export interface CceNodePoolStorageSelector {
    matchLabelCount?: string;
    matchLabelMetadataCmkid?: string;
    matchLabelMetadataEncrypted?: string;
    matchLabelSize?: string;
    matchLabelVolumeType?: string;
    name: string;
    type?: string;
}

export interface CceNodePoolTaint {
    effect: string;
    key: string;
    value: string;
}

export interface CceNodeRootVolume {
    dssPoolId: string;
    /**
     * @deprecated use extendParams instead
     */
    extendParam?: string;
    extendParams: {[key: string]: string};
    /**
     * schema: Internal
     */
    hwPassthrough: boolean;
    iops: number;
    kmsKeyId: string;
    size: number;
    throughput: number;
    volumetype: string;
}

export interface CceNodeStorage {
    groups: outputs.CceNodeStorageGroup[];
    selectors: outputs.CceNodeStorageSelector[];
}

export interface CceNodeStorageGroup {
    cceManaged?: boolean;
    name: string;
    selectorNames: string[];
    virtualSpaces: outputs.CceNodeStorageGroupVirtualSpace[];
}

export interface CceNodeStorageGroupVirtualSpace {
    lvmLvType?: string;
    lvmPath?: string;
    name: string;
    runtimeLvType?: string;
    size: string;
}

export interface CceNodeStorageSelector {
    matchLabelCount?: string;
    matchLabelMetadataCmkid?: string;
    matchLabelMetadataEncrypted?: string;
    matchLabelSize?: string;
    matchLabelVolumeType?: string;
    name: string;
    type?: string;
}

export interface CceNodeTaint {
    effect: string;
    key: string;
    value?: string;
}

export interface CdmClusterInstance {
    id: string;
    manageIp: string;
    name: string;
    privateIp: string;
    publicIp: string;
    role: string;
    trafficIp: string;
    type: string;
}

export interface CesAlarmruleAlarmAction {
    notificationLists: string[];
    type: string;
}

export interface CesAlarmruleCondition {
    comparisonOperator: string;
    count: number;
    filter: string;
    period: number;
    suppressDuration?: number;
    unit?: string;
    value: number;
}

export interface CesAlarmruleInsufficientdataAction {
    notificationLists: string[];
    type: string;
}

export interface CesAlarmruleMetric {
    dimensions?: outputs.CesAlarmruleMetricDimension[];
    metricName: string;
    namespace: string;
}

export interface CesAlarmruleMetricDimension {
    name: string;
    value: string;
}

export interface CesAlarmruleOkAction {
    notificationLists: string[];
    type: string;
}

export interface CfwAclRuleCustomService {
    /**
     * The destination port.
     */
    destPort: string;
    /**
     * The protocol type.
     */
    protocol: number;
    /**
     * The source port.
     */
    sourcePort: string;
}

export interface CfwAclRuleCustomServiceGroups {
    /**
     * The IDs of the service groups.
     */
    groupIds: string[];
    /**
     * The protocols used in the service groups.
     */
    protocols: number[];
}

export interface CfwAclRuleDestinationRegionList {
    /**
     * The Chinese description of the region.
     */
    descriptionCn?: string;
    /**
     * The English description of the region.
     */
    descriptionEn?: string;
    /**
     * The region ID.
     */
    regionId: string;
    /**
     * The region type.
     */
    regionType: number;
}

export interface CfwAclRulePredefinedServiceGroups {
    /**
     * The IDs of the service groups.
     */
    groupIds: string[];
    /**
     * The protocols used in the service groups.
     */
    protocols: number[];
}

export interface CfwAclRuleSequence {
    /**
     * Whether to pin on bottom.
     */
    bottom?: number;
    /**
     * The ID of the rule that the added rule will follow.
     */
    destRuleId: string;
    /**
     * Whether to pin on top.
     */
    top?: number;
}

export interface CfwAclRuleSourceRegionList {
    /**
     * The Chinese description of the region.
     */
    descriptionCn?: string;
    /**
     * The English description of the region.
     */
    descriptionEn?: string;
    /**
     * The region ID.
     */
    regionId: string;
    /**
     * The region type.
     */
    regionType: number;
}

export interface CfwAntiVirusScanProtocolConfig {
    /**
     * The antivirus action.
     */
    action: number;
    /**
     * The protocol type.
     */
    protocolType: number;
}

export interface CfwCaptureTaskDestination {
    /**
     * The address.
     */
    address: string;
    /**
     * The address type.
     */
    addressType: number;
}

export interface CfwCaptureTaskService {
    /**
     * The destination port.
     */
    destPort?: string;
    /**
     * The protocol type.
     */
    protocol: number;
    /**
     * The source port.
     */
    sourcePort?: string;
}

export interface CfwCaptureTaskSource {
    /**
     * The address.
     */
    address: string;
    /**
     * The address type.
     */
    addressType: number;
}

export interface CfwDomainNameGroupDomainName {
    /**
     * Specifies the description.
     */
    description: string;
    /**
     * The DNS IP list.
     */
    dnsIps: string;
    /**
     * The domain address ID.
     */
    domainAddressId: string;
    /**
     * Specifies the domain name.
     */
    domainName: string;
}

export interface CfwEipProtectionProtectedEip {
    /**
     * The ID of the protected EIP.
     */
    id: string;
    /**
     * The IPv4 address of the protected EIP.
     */
    publicIpv4: string;
    /**
     * The IPv6 address of the protected EIP.
     */
    publicIpv6: string;
}

export interface CfwFirewallFlavor {
    /**
     * Specifies the bandwidth of the firewall.
     */
    bandwidth: number;
    /**
     * Specifies the default bandwidth of the firewall.
     */
    defaultBandwidth: number;
    /**
     * Specifies the default EIP number of the firewall.
     */
    defaultEipCount: number;
    /**
     * Specifies the default log storage of the firewall.
     */
    defaultLogStorage: number;
    /**
     * Specifies the default VPC number of the firewall.
     */
    defaultVpcCount: number;
    /**
     * Specifies the EIP number of the firewall.
     */
    eipCount: number;
    /**
     * Specifies the extend bandwidth of the firewall.
     */
    extendBandwidth?: number;
    /**
     * Specifies the extend EIP number of the firewall.
     */
    extendEipCount?: number;
    /**
     * Specifies the extend VPC number of the firewall.
     */
    extendVpcCount?: number;
    /**
     * Specifies the log storage of the firewall.
     */
    logStorage: number;
    /**
     * Specifies the total rule count of the firewall.
     */
    totalRuleCount: number;
    /**
     * Specifies the used rule count of the firewall.
     */
    usedRuleCount: number;
    /**
     * Specifies the version of the firewall.
     */
    version: string;
    /**
     * Specifies the VPC bandwidth of the firewall.
     */
    vpcBandwidth: number;
    /**
     * Specifies the VPC number of the firewall.
     */
    vpcCount: number;
}

export interface CfwFirewallProtectObject {
    /**
     * Protected object ID
     */
    objectId: string;
    /**
     * Protected object name
     */
    objectName: string;
    /**
     * Project type. The options are as follows: 0: north-south; 1: east-west.
     */
    type: number;
}

export interface ComputeInstanceBandwidth {
    chargeMode?: string;
    extendParam?: {[key: string]: string};
    id?: string;
    shareType: string;
    size?: number;
}

export interface ComputeInstanceDataDisk {
    dssPoolId?: string;
    iops?: number;
    kmsKeyId?: string;
    size: number;
    snapshotId?: string;
    throughput?: number;
    type: string;
}

export interface ComputeInstanceNetwork {
    accessNetwork?: boolean;
    fixedIpV4: string;
    /**
     * schema: Computed
     */
    fixedIpV6: string;
    ipv6Enable?: boolean;
    mac: string;
    /**
     * schema: Computed
     */
    port: string;
    sourceDestCheck?: boolean;
    /**
     * schema: Required
     */
    uuid: string;
}

export interface ComputeInstanceSchedulerHint {
    dehId?: string;
    /**
     * schema: Internal
     */
    faultDomain?: string;
    group: string;
    tenancy?: string;
}

export interface ComputeInstanceVolumeAttached {
    bootIndex: number;
    kmsKeyId: string;
    pciAddress: string;
    size: number;
    type: string;
    volumeId: string;
}

export interface CssClusterBackupStrategy {
    agency: string;
    backupPath: string;
    bucket: string;
    keepDays?: number;
    prefix?: string;
    startTime: string;
}

export interface CssClusterClientNodeConfig {
    flavor: string;
    instanceNumber: number;
    shrinkNodeIds?: string[];
    volume: outputs.CssClusterClientNodeConfigVolume;
}

export interface CssClusterClientNodeConfigVolume {
    size: number;
    volumeType: string;
}

export interface CssClusterColdNodeConfig {
    flavor: string;
    instanceNumber: number;
    shrinkNodeIds?: string[];
    volume: outputs.CssClusterColdNodeConfigVolume;
}

export interface CssClusterColdNodeConfigVolume {
    size: number;
    volumeType: string;
}

export interface CssClusterEssNodeConfig {
    flavor: string;
    instanceNumber: number;
    shrinkNodeIds?: string[];
    volume: outputs.CssClusterEssNodeConfigVolume;
}

export interface CssClusterEssNodeConfigVolume {
    size: number;
    volumeType: string;
}

export interface CssClusterKibanaPublicAccess {
    bandwidth: number;
    publicIp: string;
    whitelist?: string;
    whitelistEnabled: boolean;
}

export interface CssClusterMasterNodeConfig {
    flavor: string;
    instanceNumber: number;
    shrinkNodeIds?: string[];
    volume: outputs.CssClusterMasterNodeConfigVolume;
}

export interface CssClusterMasterNodeConfigVolume {
    size: number;
    volumeType: string;
}

export interface CssClusterNode {
    availabilityZone: string;
    id: string;
    ip: string;
    name: string;
    resourceId: string;
    specCode: string;
    status: string;
    type: string;
}

export interface CssClusterNodeConfig {
    availabilityZone: string;
    flavor: string;
    networkInfo: outputs.CssClusterNodeConfigNetworkInfo;
    volume: outputs.CssClusterNodeConfigVolume;
}

export interface CssClusterNodeConfigNetworkInfo {
    securityGroupId: string;
    subnetId: string;
    vpcId: string;
}

export interface CssClusterNodeConfigVolume {
    size: number;
    volumeType: string;
}

export interface CssClusterPublicAccess {
    bandwidth: number;
    publicIp: string;
    whitelist?: string;
    whitelistEnabled: boolean;
}

export interface CssClusterVpcepEndpoint {
    endpointWithDnsName: boolean;
    whitelists?: string[];
}

export interface CtsNotificationFilter {
    condition: string;
    rules: string[];
}

export interface CtsNotificationOperation {
    resource: string;
    service: string;
    traceNames: string[];
}

export interface CtsNotificationOperationUser {
    group: string;
    users: string[];
}

export interface DcsInstanceBackupPolicy {
    backupAts: number[];
    backupType?: string;
    beginAt: string;
    periodType?: string;
    saveDays?: number;
}

export interface DcsInstanceBandwidthInfo {
    bandwidth: number;
    beginTime: string;
    currentTime: string;
    endTime: string;
    expandCount: number;
    expandEffectTime: number;
    expandIntervalTime: number;
    maxExpandCount: number;
    nextExpandTime: string;
    taskRunning: boolean;
}

export interface DcsInstanceParameter {
    id: string;
    name: string;
    value: string;
}

export interface DcsInstanceWhitelist {
    groupName: string;
    ipAddresses: string[];
}

export interface DcsParametersConfigurationParameter {
    name: string;
    needRestart: boolean;
    type: string;
    userPermission: string;
    value: string;
}

export interface DcsRestoreRestoreRecord {
    backupId: string;
    backupName: string;
    backupRemark: string;
    createdAt: string;
    errorCode: string;
    progress: string;
    restoreId: string;
    restoreName: string;
    restoreRemark: string;
    sourceInstanceId: string;
    sourceInstanceName: string;
    status: string;
    updatedAt: string;
}

export interface DdsInstanceBackupStrategy {
    keepDays: number;
    period: string;
    startTime: string;
}

export interface DdsInstanceConfiguration {
    id: string;
    type: string;
}

export interface DdsInstanceDatastore {
    storageEngine?: string;
    type: string;
    version: string;
}

export interface DdsInstanceFlavor {
    num: number;
    size?: number;
    specCode: string;
    storage?: string;
    type: string;
}

export interface DdsInstanceGroup {
    id: string;
    name: string;
    nodes: outputs.DdsInstanceGroupNode[];
    size: string;
    status: string;
    type: string;
    used: string;
}

export interface DdsInstanceGroupNode {
    /**
     * Indicates the node ID.
     */
    id: string;
    /**
     * Indicates the node name.
     */
    name: string;
    /**
     * Indicates the private IP address of a node.
     */
    privateIp: string;
    /**
     * Indicates the EIP that has been bound on a node.
     */
    publicIp: string;
    /**
     * Indicates the node role.
     */
    role: string;
    /**
     * Indicates the node status.
     */
    status: string;
    /**
     * Indicates the node type.
     */
    type: string;
}

export interface DdsInstanceNode {
    /**
     * Indicates the node ID.
     */
    id: string;
    /**
     * Indicates the node name.
     */
    name: string;
    /**
     * Indicates the private IP address of a node.
     */
    privateIp: string;
    /**
     * Indicates the EIP that has been bound on a node.
     */
    publicIp: string;
    /**
     * Indicates the node role.
     */
    role: string;
    /**
     * Indicates the node status.
     */
    status: string;
    /**
     * Indicates the node type.
     */
    type: string;
}

export interface DdsParameterTemplateCompareDifference {
    parameterName: string;
    sourceValue: string;
    targetValue: string;
}

export interface DdsParameterTemplateCopyParameter {
    /**
     * Indicates the parameter description.
     */
    description: string;
    /**
     * Indicates the parameter name.
     */
    name: string;
    /**
     * Indicates whether the parameter is read-only.
     */
    readonly: boolean;
    /**
     * Indicates whether the instance needs to be restarted.
     */
    restartRequired: boolean;
    /**
     * Indicates the parameter type.
     */
    type: string;
    /**
     * Indicates the parameter value.
     */
    value: string;
    /**
     * Indicates the value range.
     */
    valueRange: string;
}

export interface DdsParameterTemplateParameter {
    /**
     * Indicates the parameter description.
     */
    description: string;
    /**
     * Indicates the parameter name.
     */
    name: string;
    /**
     * Indicates whether the parameter is read-only.
     */
    readonly: boolean;
    /**
     * Indicates whether the instance needs to be restarted.
     */
    restartRequired: boolean;
    /**
     * Indicates the parameter type.
     */
    type: string;
    /**
     * Indicates the parameter value.
     */
    value: string;
    /**
     * Indicates the value range.
     */
    valueRange: string;
}

export interface DisStreamPartition {
    hashRange: string;
    id: string;
    sequenceNumberRange: string;
    status: string;
}

export interface DliQueueScalingPolicy {
    impactStartTime: string;
    impactStopTime: string;
    maxCu: number;
    minCu: number;
    priority: number;
}

export interface DliQueueSparkDriver {
    maxConcurrent?: number;
    maxInstance?: number;
    maxPrefetchInstance?: string;
}

export interface DliSparkJobDependentPackage {
    groupName: string;
    packages: outputs.DliSparkJobDependentPackagePackage[];
}

export interface DliSparkJobDependentPackagePackage {
    packageName: string;
    type: string;
}

export interface DmsKafkaInstanceCrossVpcAccess {
    advertisedIp: string;
    /**
     * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
     */
    lisenterIp: string;
    listenerIp: string;
    port: number;
    portId: string;
}

export interface DmsKafkaInstanceParameter {
    name: string;
    value: string;
}

export interface DmsKafkaInstancePortProtocol {
    privatePlainAddress: string;
    privatePlainDomainName: string;
    privatePlainEnable: boolean;
    privateSaslPlaintextAddress: string;
    privateSaslPlaintextDomainName: string;
    privateSaslPlaintextEnable: boolean;
    privateSaslSslAddress: string;
    privateSaslSslDomainName: string;
    privateSaslSslEnable: boolean;
    publicPlainAddress: string;
    publicPlainDomainName: string;
    publicPlainEnable: boolean;
    publicSaslPlaintextAddress: string;
    publicSaslPlaintextDomainName: string;
    publicSaslPlaintextEnable: boolean;
    publicSaslSslAddress: string;
    publicSaslSslDomainName: string;
    publicSaslSslEnable: boolean;
}

export interface DmsKafkaMessageProducePropertyList {
    name: string;
    value: string;
}

export interface DmsKafkaPermissionsPolicy {
    accessPolicy: string;
    userName: string;
}

export interface DmsKafkaTopicConfig {
    name: string;
    value: string;
}

export interface DmsRocketmqConsumptionVerifyResendResult {
    /**
     * Indicates the error code.
     */
    errorCode: string;
    /**
     * Indicates the error message.
     */
    errorMessage: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
}

export interface DmsRocketmqDeadLetterResendResendResult {
    /**
     * Indicates the error code.
     */
    errorCode: string;
    /**
     * Indicates the error message.
     */
    errorMessage: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
}

export interface DmsRocketmqInstanceConfig {
    name: string;
    value: string;
}

export interface DmsRocketmqInstanceCrossVpcAccess {
    advertisedIp: string;
    /**
     * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
     */
    lisenterIp: string;
    listenerIp: string;
    port: number;
    portId: string;
}

export interface DmsRocketmqMigrationTaskBinding {
    /**
     * Specifies the message target.
     */
    destination?: string;
    /**
     * Specifies the message target type.
     */
    destinationType: string;
    /**
     * Specifies the routing key.
     */
    routingKey: string;
    /**
     * Specifies the message source.
     */
    source: string;
    /**
     * Specifies the virtual host name.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskExchange {
    /**
     * Specifies whether to enable data persistence.
     */
    durable: boolean;
    /**
     * Specifies the switch name.
     */
    name: string;
    /**
     * Specifies the exchange type.
     */
    type: string;
    /**
     * Specifies the virtual host name.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskQueue {
    /**
     * Specifies whether to enable data persistence.
     */
    durable: boolean;
    /**
     * Specifies the queue name.
     */
    name: string;
    /**
     * Specifies the virtual host name.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskSubscriptionGroup {
    /**
     * Specifies whether to enable broadcast.
     */
    consumeBroadcastEnable: boolean;
    /**
     * Specifies whether to enable consumption.
     */
    consumeEnable: boolean;
    /**
     * Specifies whether to enable consumption from the earliest offset.
     */
    consumeFromMinEnable: boolean;
    /**
     * Specifies the name of a consumer group.
     */
    groupName: string;
    /**
     * Specifies whether to notify changes of consumer IDs.
     */
    notifyConsumeridsChangedEnable: boolean;
    /**
     * Specifies the maximum number of consumption retries.
     */
    retryMaxTimes: number;
    /**
     * Specifies the number of retry queues.
     */
    retryQueueNum: number;
    /**
     * Specifies the ID of the broker selected for slow consumption.
     */
    whichBrokerWhenConsumeSlow: number;
}

export interface DmsRocketmqMigrationTaskTopicConfig {
    /**
     * Specifies whether a message is an ordered message.
     */
    order: boolean;
    /**
     * Specifies the number of permission.
     */
    perm: number;
    /**
     * Specifies the number of read queues.
     */
    readQueueNum: number;
    /**
     * Specifies the filter type of a topic.
     */
    topicFilterType: string;
    /**
     * Specifies the topic name.
     */
    topicName: string;
    /**
     * Specifies the system flag of a topic.
     */
    topicSysFlag: number;
    /**
     * Specifies the number of write queues.
     */
    writeQueueNum: number;
}

export interface DmsRocketmqMigrationTaskVhost {
    /**
     * Specifies the virtual host name.
     */
    name: string;
}

export interface DmsRocketmqTopicBroker {
    /**
     * Indicates the name of the broker.
     */
    name: string;
    /**
     * Indicates the read queues number of the broker.
     */
    readQueueNum: number;
    /**
     * Indicates the read queues number of the broker.
     */
    writeQueueNum: number;
}

export interface DmsRocketmqTopicQueue {
    /**
     * Specifies the associated broker.
     */
    broker?: string;
    /**
     * Specifies the number of the queues.
     */
    queueNum?: number;
}

export interface DmsRocketmqUserGroupPerm {
    /**
     * Indicates the name of a topic or consumer group.
     */
    name: string;
    /**
     * Indicates the permissions of the topic or consumer group.
     * Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
     */
    perm: string;
}

export interface DmsRocketmqUserTopicPerm {
    /**
     * Indicates the name of a topic or consumer group.
     */
    name: string;
    /**
     * Indicates the permissions of the topic or consumer group.
     * Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
     */
    perm: string;
}

export interface DnsZoneRouter {
    /**
     * The ID of the associated VPC.
     */
    routerId: string;
    /**
     * The region of the VPC.
     */
    routerRegion: string;
}

export interface DrsJobDestinationDb {
    engineType: string;
    instanceId?: string;
    ip: string;
    name: string;
    password: string;
    port: number;
    region: string;
    sslCertCheckSum?: string;
    sslCertKey?: string;
    sslCertName?: string;
    sslCertPassword?: string;
    sslEnabled?: boolean;
    subnetId?: string;
    user: string;
}

export interface DrsJobLimitSpeed {
    endTime: string;
    speed: string;
    startTime: string;
}

export interface DrsJobSourceDb {
    engineType: string;
    instanceId?: string;
    ip: string;
    name: string;
    password: string;
    port: number;
    region: string;
    sslCertCheckSum?: string;
    sslCertKey?: string;
    sslCertName?: string;
    sslCertPassword?: string;
    sslEnabled?: boolean;
    subnetId?: string;
    user: string;
}

export interface DwsClusterElb {
    /**
     * The ID of the ELB load balancer.
     */
    id: string;
    /**
     * The name of the ELB load balancer.
     */
    name: string;
    /**
     * The private endpoint of the ELB load balancer.
     */
    privateEndpoint: string;
    /**
     * The private IP address of the ELB load balancer.
     */
    privateIp: string;
    /**
     * The IPv6 address of the ELB load balancer.
     */
    privateIpV6: string;
    /**
     * The public IP address of the ELB load balancer.
     */
    publicIp: string;
    /**
     * The ID of VPC to which the ELB load balancer belongs.
     */
    vpcId: string;
}

export interface DwsClusterEndpoint {
    /**
     * Private network connection information.
     */
    connectInfo: string;
    /**
     * JDBC URL. Format: jdbc:postgresql://<connect_info>/<YOUR_DATABASE_NAME>
     */
    jdbcUrl: string;
}

export interface DwsClusterMaintainWindow {
    /**
     * Maintenance time in each week in the unit of day.
     */
    day: string;
    /**
     * Maintenance end time in HH:mm format. The time zone is GMT+0.
     */
    endTime: string;
    /**
     * Maintenance start time in HH:mm format. The time zone is GMT+0.
     */
    startTime: string;
}

export interface DwsClusterPublicEndpoint {
    /**
     * JDBC URL. Format: jdbc:postgresql://<public_connect_info>/<YOUR_DATABASE_NAME>
     */
    jdbcUrl: string;
    /**
     * Public network connection information.
     */
    publicConnectInfo: string;
}

export interface DwsClusterPublicIp {
    /**
     * The EIP ID.
     */
    eipId?: string;
    /**
     * The bind type of public IP.
     */
    publicBindType: string;
}

export interface DwsClusterVolume {
    /**
     * The capacity size, in GB.
     */
    capacity: string;
    /**
     * The volume type.
     */
    type: string;
}

export interface ElbIpgroupIpList {
    description?: string;
    ip: string;
}

export interface ElbL7policyFixedResponseConfig {
    contentType: string;
    insertHeadersConfig?: outputs.ElbL7policyFixedResponseConfigInsertHeadersConfig;
    messageBody?: string;
    removeHeadersConfig?: outputs.ElbL7policyFixedResponseConfigRemoveHeadersConfig;
    statusCode: string;
    trafficLimitConfig?: outputs.ElbL7policyFixedResponseConfigTrafficLimitConfig;
}

export interface ElbL7policyFixedResponseConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyFixedResponseConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyFixedResponseConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyFixedResponseConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyFixedResponseConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyFixedResponseConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7policyFixedResponseConfigTrafficLimitConfig {
    burst?: number;
    perSourceIpQps?: number;
    qps?: number;
}

export interface ElbL7policyRedirectPoolsConfig {
    poolId: string;
    weight: number;
}

export interface ElbL7policyRedirectPoolsExtendConfig {
    insertHeadersConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfig;
    removeHeadersConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfig;
    rewriteUrlConfig: outputs.ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfig;
    rewriteUrlEnabled: boolean;
    trafficLimitConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfig;
}

export interface ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfig {
    host: string;
    path: string;
    query?: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfig {
    burst?: number;
    perSourceIpQps?: number;
    qps?: number;
}

export interface ElbL7policyRedirectPoolsStickySessionConfig {
    enable: boolean;
    timeout: number;
}

export interface ElbL7policyRedirectUrlConfig {
    host: string;
    insertHeadersConfig?: outputs.ElbL7policyRedirectUrlConfigInsertHeadersConfig;
    path: string;
    port: string;
    protocol: string;
    query?: string;
    removeHeadersConfig?: outputs.ElbL7policyRedirectUrlConfigRemoveHeadersConfig;
    statusCode: string;
}

export interface ElbL7policyRedirectUrlConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyRedirectUrlConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyRedirectUrlConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyRedirectUrlConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7ruleCondition {
    key?: string;
    value: string;
}

export interface ElbListenerPortRange {
    endPort: number;
    startPort: number;
}

export interface ElbMemberReason {
    expectedResponse: string;
    healthcheckResponse: string;
    reasonCode: string;
}

export interface ElbMemberStatus {
    listenerId: string;
    operatingStatus: string;
    reasons: outputs.ElbMemberStatusReason[];
}

export interface ElbMemberStatusReason {
    expectedResponse: string;
    healthcheckResponse: string;
    reasonCode: string;
}

export interface ElbPoolPersistence {
    cookieName?: string;
    timeout: number;
    type: string;
}

export interface ElbSecurityPolicyListener {
    id: string;
}

export interface EvsVolumeAttachment {
    attachedAt: string;
    attachedVolumeId: string;
    device: string;
    hostName: string;
    id: string;
    instanceId: string;
    volumeId: string;
}

export interface EvsVolumeIopsAttribute {
    frozened: boolean;
    id: string;
    totalVal: number;
}

export interface EvsVolumeLink {
    href: string;
    rel: string;
}

export interface EvsVolumeThroughputAttribute {
    frozened: boolean;
    id: string;
    totalVal: number;
}

export interface FgsApplicationRepository {
    /**
     * The HTTP address of the repository.
     */
    httpsUrl: string;
    /**
     * The project ID of the repository.
     */
    projectId: string;
    /**
     * The repository status.
     */
    status: string;
    /**
     * The repository link.
     */
    webUrl: string;
}

export interface FgsApplicationStackResource {
    /**
     * The cloud service name.
     */
    displayName: string;
    /**
     * The hyperlink.
     */
    href: string;
    /**
     * The logical resource name.
     */
    logicalResourceName: string;
    /**
     * The logical resource type.
     */
    logicalResourceType: string;
    /**
     * The physical resource ID.
     */
    physicalResourceId: string;
    /**
     * The physical resource name.
     */
    physicalResourceName: string;
    /**
     * The status of resource.
     */
    resourceStatus: string;
    /**
     * The status information.
     */
    statusMessage: string;
}

export interface FgsAsyncInvokeConfigurationOnFailure {
    /**
     * The object type.
     */
    destination: string;
    /**
     * The parameters (in JSON format) corresponding to the target service.
     */
    param: string;
}

export interface FgsAsyncInvokeConfigurationOnSuccess {
    /**
     * The object type.
     */
    destination: string;
    /**
     * The parameters (in JSON format) corresponding to the target service.
     */
    param: string;
}

export interface FgsFunctionCustomImage {
    /**
     * The command line arguments used to start the SWR image.
     */
    args?: string;
    /**
     * The startup commands of the SWR image.
     */
    command?: string;
    /**
     * The URL of SWR image.
     */
    url: string;
    /**
     * The user group ID that used to run SWR image.
     */
    userGroupId?: string;
    /**
     * The user ID that used to run SWR image.
     */
    userId?: string;
    /**
     * The working directory of the SWR image.
     */
    workingDir: string;
}

export interface FgsFunctionFuncMount {
    /**
     * The function access path.
     */
    localMountPath: string;
    /**
     * The ID of the mounted resource (corresponding cloud service).
     */
    mountResource: string;
    /**
     * The remote mount path.
     */
    mountSharePath: string;
    /**
     * The mount type.
     */
    mountType: string;
    /**
     * The mount status.
     */
    status: string;
}

export interface FgsFunctionNetworkController {
    /**
     * Whether to disable the public network access.
     */
    disablePublicNetwork?: boolean;
    /**
     * The configuration of the VPCs that can trigger the function.
     */
    triggerAccessVpcs: outputs.FgsFunctionNetworkControllerTriggerAccessVpc[];
}

export interface FgsFunctionNetworkControllerTriggerAccessVpc {
    /**
     * The ID of the VPC that can trigger the function.
     */
    vpcId: string;
    /**
     * The ID of the VPC that can trigger the function.
     */
    vpcName: string;
}

export interface FgsFunctionReservedInstance {
    /**
     * The number of reserved instance.
     */
    count: number;
    /**
     * Whether to enable the idle mode.
     */
    idleMode?: boolean;
    /**
     * The version name or alias name.
     */
    qualifierName: string;
    /**
     * The qualifier type of reserved instance.
     */
    qualifierType: string;
    /**
     * The auto scaling policies for reserved instance.
     */
    tacticsConfig?: outputs.FgsFunctionReservedInstanceTacticsConfig;
}

export interface FgsFunctionReservedInstanceTacticsConfig {
    /**
     * The list of scheduled policy configurations.
     */
    cronConfigs?: outputs.FgsFunctionReservedInstanceTacticsConfigCronConfig[];
    /**
     * The list of metric policy configurations.
     */
    metricConfigs?: outputs.FgsFunctionReservedInstanceTacticsConfigMetricConfig[];
}

export interface FgsFunctionReservedInstanceTacticsConfigCronConfig {
    /**
     * The number of reserved instance to which the policy belongs.
     */
    count: number;
    /**
     * The cron expression.
     */
    cron: string;
    /**
     * The expiration timestamp of the policy.
     */
    expiredTime: number;
    /**
     * The name of scheduled policy configuration.
     */
    name: string;
    /**
     * The effective timestamp of policy.
     */
    startTime: number;
}

export interface FgsFunctionReservedInstanceTacticsConfigMetricConfig {
    /**
     * The minimun of traffic.
     */
    min: number;
    /**
     * The name of metric policy.
     */
    name: string;
    /**
     * The metric policy threshold.
     */
    threshold: number;
    /**
     * The type of metric policy.
     */
    type: string;
}

export interface FgsFunctionVersion {
    /**
     * The aliases management for specified version.
     */
    aliases?: outputs.FgsFunctionVersionAliases;
    /**
     * The description of the version.
     */
    description?: string;
    /**
     * The version name.
     */
    name: string;
}

export interface FgsFunctionVersionAliases {
    /**
     * The description of the version alias.
     */
    additionalVersionStrategy?: string;
    /**
     * The percentage grayscale configuration of the version alias.
     */
    additionalVersionWeights?: string;
    /**
     * The description of the version alias.
     */
    description?: string;
    /**
     * The name of the version alias.
     */
    name: string;
}

export interface GesGraphEncryption {
    /**
     * Whether to enable data encryption The value can be true or false. The default value is false.
     */
    enable: boolean;
    /**
     * ID of the customer master key created by DEW in the project corresponding to the graph creation.
     */
    masterKeyId: string;
}

export interface GesGraphLtsOperationTrace {
    /**
     * LTS log group name.
     */
    auditLogGroupName: string;
    /**
     * Whether to enable graph audit. The default value is false.
     */
    enableAudit: boolean;
}

export interface GesGraphPublicIp {
    /**
     * The EIP ID.
     */
    eipId: string;
    /**
     * The bind type of public IP.
     */
    publicBindType: string;
}

export interface GesGraphVertexIdType {
    /**
     * The length of ID.
     */
    idLength: number;
    /**
     * Vertex ID type.
     */
    idType: string;
}

export interface GetApigAclPoliciesPolicy {
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The entity type of the ACL policy.
     */
    entityType: string;
    /**
     * The ID of the ACL policy.
     */
    id: string;
    /**
     * The name of the ACL policy.
     */
    name: string;
    /**
     * The type of the ACL policy.
     */
    type: string;
    /**
     * The latest update time of the policy.
     */
    updatedAt: string;
    /**
     * The value of the ACL policy.
     */
    value: string;
}

export interface GetApigApiAssociatedAclPoliciesPolicy {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the ACL policy is bound to the API.
     */
    bindTime: string;
    /**
     * The entity type of the ACL policy.
     */
    entityType: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the ACL policy.
     */
    id: string;
    /**
     * The name of the ACL policy.
     */
    name: string;
    /**
     * The type of the ACL policy.
     */
    type: string;
    /**
     * One or more objects from which the access will be controlled.
     */
    value: string;
}

export interface GetApigApiAssociatedApplicationsApplication {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the application is bound to the API.
     */
    bindTime: string;
    /**
     * The description of the application.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the application.
     */
    id: string;
    /**
     * The name of the application.
     */
    name: string;
}

export interface GetApigApiAssociatedPluginsPlugin {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the plugin is bound to the API.
     */
    bindTime: string;
    /**
     * The configuration details for the plugin.
     */
    content: string;
    /**
     * The description of the plugin.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the plugin.
     */
    id: string;
    /**
     * The name of the plugin.
     */
    name: string;
    /**
     * The type of the plugin.
     */
    type: string;
}

export interface GetApigApiAssociatedSignaturesSignature {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the signature is bound to the API.
     */
    bindTime: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the signature.
     */
    id: string;
    /**
     * The signature key.
     */
    key: string;
    /**
     * The name of the signature.
     */
    name: string;
    /**
     * The signature secret.
     */
    secret: string;
    /**
     * The type of the signature.
     */
    type: string;
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicy {
    /**
     * The array of one or more special throttling policies for APP limit.
     */
    appThrottles: outputs.GetApigApiAssociatedThrottlingPoliciesPolicyAppThrottle[];
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the throttling policy is bound to the API, in RFC3339 format.
     */
    bindTime: string;
    /**
     * The creation time of the throttling policy, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of the throttling policy.
     */
    description: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The maximum number of times the API can be accessed by an app within the same period.
     */
    maxAppRequests: number;
    /**
     * The maximum number of times the API can be accessed by an IP address within the same period.
     */
    maxIpRequests: number;
    /**
     * The maximum number of times the API can be accessed by a user within the same period.
     */
    maxUserRequests: number;
    /**
     * The name of the throttling policy.
     */
    name: string;
    /**
     * The period of time for limiting the number of API calls.
     */
    period: number;
    /**
     * The time unit for limiting the number of API calls.
     */
    periodUnit: string;
    /**
     * The type of the throttling policy.
     */
    type: string;
    /**
     * The array of one or more special throttling policies for IAM user limit.
     */
    userThrottles: outputs.GetApigApiAssociatedThrottlingPoliciesPolicyUserThrottle[];
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicyAppThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicyUserThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigApiBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiBasicConfigurationsConfiguration {
    /**
     * The ID of the authorizer to which the API request used.
     */
    authorizerId: string;
    /**
     * The backend type of the API.
     */
    backendType: string;
    /**
     * Whether CORS is supported.
     */
    cors: boolean;
    /**
     * The description of the API.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of group corresponding to the API.
     */
    groupId: string;
    /**
     * The name of group corresponding to the API.
     */
    groupName: string;
    /**
     * The version of group corresponding to the API.
     */
    groupVersion: string;
    /**
     * The ID of the API.
     */
    id: string;
    /**
     * The matching mode of the API.
     */
    matching: string;
    /**
     * The name of the API.
     */
    name: string;
    /**
     * The ID of publish corresponding to the API.
     */
    publishId: string;
    /**
     * The published time of the API, in RFC3339 format.
     */
    publishedAt: string;
    /**
     * The registered time of the API, in RFC3339 format.
     */
    registeredAt: string;
    /**
     * The request method of the API.
     */
    requestMethod: string;
    /**
     * The request address of the API.
     */
    requestPath: string;
    /**
     * The request protocol of the API.
     */
    requestProtocol: string;
    /**
     * The security authentication mode of the API request.
     */
    securityAuthentication: string;
    /**
     * Whether the authentication of the application code is enabled.
     */
    simpleAuthentication: boolean;
    /**
     * The list of tags configuration.
     */
    tags: string[];
    /**
     * The type of the API.
     */
    type: string;
    /**
     * The latest update time of the API, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigApiFuncGraph {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The ID of the FunctionGraph backend configuration.
     */
    id: string;
    /**
     * The invocation type.
     */
    invocationType: string;
    /**
     * The network architecture (framework) type of the FunctionGraph function.
     */
    networkType: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The version of the FunctionGraph function.
     */
    version: string;
}

export interface GetApigApiFuncGraphPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The configaiton list of the backend parameters.
     */
    backendParams: outputs.GetApigApiFuncGraphPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiFuncGraphPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The ID of the FunctionGraph backend policy.
     */
    id: string;
    /**
     * The invocation mode of the FunctionGraph function.
     */
    invocationType: string;
    /**
     * The name of the backend policy.
     */
    name: string;
    /**
     * The network (framework) type of the FunctionGraph function.
     */
    networkType: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The version of the FunctionGraph function.
     */
    version: string;
}

export interface GetApigApiFuncGraphPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiFuncGraphPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigApiMock {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The ID of the mock backend configuration.
     */
    id: string;
    /**
     * The response of the mock backend configuration.
     */
    response: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface GetApigApiMockPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The configuration list of backend parameters.
     */
    backendParams: outputs.GetApigApiMockPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiMockPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The ID of the mock backend policy.
     */
    id: string;
    /**
     * The backend policy name.
     */
    name: string;
    /**
     * The response of the backend policy.
     */
    response: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface GetApigApiMockPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiMockPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigApiRequestParam {
    /**
     * The default value of the parameter.
     */
    default: string;
    /**
     * The parameter description.
     */
    description: string;
    /**
     * The enumerated value.
     */
    enumeration: string;
    /**
     * The parameter example.
     */
    example: string;
    /**
     * The ID of the request parameter.
     */
    id: string;
    /**
     * Where this parameter is located.
     */
    location: string;
    /**
     * The maximum value or length (string parameter) for parameter.
     */
    maximum: number;
    /**
     * The minimum value or length (string parameter) for parameter.
     */
    minimum: number;
    /**
     * The name of the request parameter.
     */
    name: string;
    /**
     * Whether to transparently transfer the parameter.
     */
    passthrough: boolean;
    /**
     * Whether this parameter is required.
     */
    required: boolean;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * Whether to enable the parameter validation.
     */
    validEnable: number;
}

export interface GetApigApiWeb {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The backend service address.
     */
    backendAddress: string;
    /**
     * The proxy host header.
     */
    hostHeader: string;
    /**
     * The ID of the backend configuration.
     */
    id: string;
    /**
     * The backend request path.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod: string;
    /**
     * The web protocol type of the API request.
     */
    requestProtocol: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount: number;
    /**
     * Whether to enable two-way authentication.
     */
    sslEnable: boolean;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId: string;
}

export interface GetApigApiWebPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The backend service address
     */
    backendAddress: string;
    /**
     * The configuration list of the backend parameters.
     */
    backendParams: outputs.GetApigApiWebPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiWebPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The proxy host header.
     */
    hostHeader: string;
    /**
     * The ID of the web policy.
     */
    id: string;
    /**
     * The name of the web policy.
     */
    name: string;
    /**
     * The backend request address.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod: string;
    /**
     * The backend request protocol.
     */
    requestProtocol: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount: number;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId: string;
}

export interface GetApigApiWebPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiWebPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigAppcodesAppcode {
    /**
     * The ID of the application.
     */
    applicationId: string;
    /**
     * The creation time of the APPCODE, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The ID of the APPCODE.
     */
    id: string;
    /**
     * The APPCODE value (content).
     */
    value: string;
}

export interface GetApigApplicationQuotasQuota {
    /**
     * The number of applications bound to the quota policy.
     */
    boundAppNum: number;
    /**
     * The maximum number of times a application quota can be called.
     */
    callLimits: number;
    /**
     * The creation time of the application quota, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of the application quota.
     */
    description: string;
    /**
     * The ID of the application quota.
     */
    id: string;
    /**
     * The name of the application quota.
     */
    name: string;
    /**
     * The time limit of a quota.
     */
    timeInterval: number;
    /**
     * The time unit.
     */
    timeUnit: string;
}

export interface GetApigApplicationsApplication {
    /**
     * The key of the application.
     */
    appKey: string;
    /**
     * The secret of the application.
     */
    appSecret: string;
    /**
     * The type of the application.
     */
    appType: string;
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The creation time of the application.
     */
    createdAt: string;
    /**
     * The creator of the application.
     */
    createdBy: string;
    /**
     * The description of the application.
     */
    description: string;
    /**
     * The ID of the application.
     */
    id: string;
    /**
     * The name of the application.
     */
    name: string;
    /**
     * The status of the application.
     */
    status: number;
    /**
     * The latest update time of the application.
     */
    updatedAt: string;
}

export interface GetApigChannelsVpcChannel {
    /**
     * The distribution algorithm.
     */
    balanceStrategy: number;
    /**
     * The creation time of channel, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The ID of the VPC channel.
     */
    id: string;
    /**
     * The parameter member groups of the VPC channels.
     */
    memberGroups: outputs.GetApigChannelsVpcChannelMemberGroup[];
    /**
     * The member type of the VPC channel.
     */
    memberType: string;
    /**
     * The name of the VPC channel.
     */
    name: string;
    /**
     * The port of the backend server.
     */
    port: number;
    /**
     * The type of the VPC channel.
     */
    type: number;
}

export interface GetApigChannelsVpcChannelMemberGroup {
    /**
     * The description of the member group.
     */
    description: string;
    /**
     * The ID of the member group.
     */
    id: string;
    /**
     * The microservice tags of the backend server group.
     */
    microserviceLabels: outputs.GetApigChannelsVpcChannelMemberGroupMicroserviceLabel[];
    /**
     * The microservice port of the backend server group.
     */
    microservicePort: number;
    /**
     * The microservice version of the backend server group.
     */
    microserviceVersion: string;
    /**
     * The name of the member group.
     */
    name: string;
    /**
     * The weight of the current member group.
     */
    weight: number;
}

export interface GetApigChannelsVpcChannelMemberGroupMicroserviceLabel {
    /**
     * The name of the microservice label.
     */
    name: string;
    /**
     * The value of the microservice label.
     */
    value: string;
}

export interface GetApigCustomAuthorizersAuthorizer {
    /**
     * The maximum cache age of custom authorizer.
     */
    cacheAge: number;
    /**
     * The creation time of custom authorizer.
     */
    createdAt: string;
    /**
     * The version alias URI of the FGS function.
     */
    functionAliasUri: string;
    /**
     * The type of the FGS function.
     */
    functionType: string;
    /**
     * The URN of the FGS function.
     */
    functionUrn: string;
    /**
     * The version of the FGS function.
     */
    functionVersion: string;
    /**
     * The ID of the custom authorizer.
     */
    id: string;
    /**
     * The parameter identities of the custom authorizer.
     */
    identities: outputs.GetApigCustomAuthorizersAuthorizerIdentity[];
    /**
     * Whether to send the body of custom authorizer.
     */
    isBodySend: boolean;
    /**
     * The name of the custom authorizer.
     */
    name: string;
    /**
     * The network architecture types of function.
     */
    networkType: string;
    /**
     * The type of the custom authorizer.
     */
    type: string;
    /**
     * The user data of custom authorizer.
     */
    userData: string;
}

export interface GetApigCustomAuthorizersAuthorizerIdentity {
    /**
     * The parameter location of identity.
     */
    location: string;
    /**
     * The name of the parameter to be verified.
     */
    name: string;
    /**
     * The parameter verification expression of identity.
     */
    validation: string;
}

export interface GetApigEndpointConnectionsConnection {
    /**
     * The creation time of the endpoint connection, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The IAM account ID of the endpoint connection creator.
     */
    domainId: string;
    /**
     * The ID of the endpoint connection.
     */
    id: string;
    /**
     * The packet ID of the endpoint connection.
     */
    packetId: number;
    /**
     * The current status of the endpoint connection.
     */
    status: string;
    /**
     * The latest time of the endpoint connection, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigEnvironmentVariablesVariable {
    /**
     * The environment ID corresponding to the environment variable.
     */
    envId: string;
    /**
     * The group ID corresponding to the environment variable.
     */
    groupId: string;
    /**
     * The ID of the environment variable.
     */
    id: string;
    /**
     * The name of the environment variable.
     */
    name: string;
    /**
     * The value of the environment variable.
     */
    value: string;
}

export interface GetApigEnvironmentsEnvironment {
    createTime: string;
    description: string;
    id: string;
    name: string;
}

export interface GetApigGroupsGroup {
    createdAt: string;
    description: string;
    /**
     * The array of one or more environments of the associated group.
     */
    environments: outputs.GetApigGroupsGroupEnvironment[];
    id: string;
    isDefault: number;
    name: string;
    onSellStatus: number;
    slDomain: string;
    slDomains: string[];
    status: number;
    updatedAt: string;
    urlDomains: outputs.GetApigGroupsGroupUrlDomain[];
}

export interface GetApigGroupsGroupEnvironment {
    /**
     * The ID of the environment to which the variables belongs.
     */
    environmentId: string;
    /**
     * The array of one or more environment variables.
     */
    variables: outputs.GetApigGroupsGroupEnvironmentVariable[];
}

export interface GetApigGroupsGroupEnvironmentVariable {
    /**
     * The ID of the variable that the group has.
     */
    id: string;
    /**
     * The variable name.
     */
    name: string;
    /**
     * The variable value.
     */
    value: string;
}

export interface GetApigGroupsGroupUrlDomain {
    cnameStatus: number;
    id: string;
    isHasTrustedRootCa: boolean;
    minSslVersion: string;
    name: string;
    sslId: string;
    sslName: string;
    verifiedClientCertificateEnabled: boolean;
}

export interface GetApigInstanceFeaturesFeature {
    /**
     * The detailed configuration of the instance feature.
     */
    config: string;
    /**
     * Whether the feature is enabled.
     */
    enabled: boolean;
    /**
     * The ID of the feature.
     */
    id: string;
    /**
     * The name of the feature.
     */
    name: string;
    /**
     * The latest update time of the feature, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigInstancesInstance {
    /**
     * The creation time of the instance, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The edition of instance.
     */
    edition: string;
    /**
     * The elastic IP address of instance binding.
     */
    eipAddress: string;
    /**
     * The enterprise project ID of the instance.
     */
    enterpriseProjectId: string;
    /**
     * The ID of instance.
     */
    id: string;
    /**
     * The type of load balancer used by the instance.
     */
    loadbalancerProvider: string;
    /**
     * The name of instance.
     */
    name: string;
    /**
     * The status of instance.
     */
    status: string;
    /**
     * The type of instance.
     */
    type: string;
}

export interface GetApigSignaturesSignature {
    /**
     * The algorithm of the signature.
     */
    algorithm: string;
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The creation time of the signature.
     */
    createdAt: string;
    /**
     * The ID of the signature.
     */
    id: string;
    /**
     * The key of the signature.
     */
    key: string;
    /**
     * The name of the signature.
     */
    name: string;
    /**
     * The secret of the signature.
     */
    secret: string;
    /**
     * The type of the signature.
     */
    type: string;
    /**
     * The latest update time of the signature.
     */
    updatedAt: string;
}

export interface GetApigThrottlingPoliciesPolicy {
    /**
     * The array of one or more special throttling policies for APP limit.
     */
    appThrottles: outputs.GetApigThrottlingPoliciesPolicyAppThrottle[];
    /**
     * The number of APIs bound to the throttling policy.
     */
    bindNum: number;
    /**
     * The creation time of the throttling policy, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of throttling policy.
     */
    description: string;
    /**
     * The ID of the throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The maximum number of times the API can be accessed by an app within the same period.
     */
    maxAppRequests: number;
    /**
     * The maximum number of times the API can be accessed by an IP address within the same period.
     */
    maxIpRequests: number;
    /**
     * The maximum number of times the API can be accessed by a user within the same period.
     */
    maxUserRequests: number;
    /**
     * The name of the throttling policy.
     */
    name: string;
    /**
     * The period of time for limiting the number of API calls.
     */
    period: number;
    /**
     * The time unit for limiting the number of API calls.
     */
    periodUnit: string;
    /**
     * The type of the throttling policy.
     */
    type: string;
    /**
     * The array of one or more special throttling policies for IAM user limit.
     */
    userThrottles: outputs.GetApigThrottlingPoliciesPolicyUserThrottle[];
}

export interface GetApigThrottlingPoliciesPolicyAppThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigThrottlingPoliciesPolicyUserThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetCbhAvailabilityZonesAvailabilityZone {
    displayName: string;
    name: string;
    regionId: string;
    status: string;
    type: string;
}

export interface GetCbhFlavorsFlavor {
    asset: number;
    dataDiskSize: number;
    ecsSystemDataSize: number;
    id: string;
    maxConnection: number;
    memory: number;
    type: string;
    vcpus: number;
}

export interface GetCbhInstancesInstance {
    /**
     * Indicates the availability zone name.
     */
    availabilityZone: string;
    /**
     * Indicates the specification of the instance.
     */
    flavorId: string;
    /**
     * Indicates the ID of the instance.
     */
    id: string;
    /**
     * Indicates the instance name.
     */
    name: string;
    /**
     * Indicates the private IP address of the instance.
     */
    privateIp: string;
    /**
     * Indicates the elastic IP address.
     */
    publicIp: string;
    /**
     * Indicates the ID of the elastic IP.
     */
    publicIpId: string;
    /**
     * Indicates the ID of a security group.
     */
    securityGroupId: string;
    /**
     * Indicates the status of the instance.
     */
    status: string;
    /**
     * Indicates the ID of a subnet.
     */
    subnetId: string;
    /**
     * Indicates the current version of the instance image.
     */
    version: string;
    /**
     * Indicates the ID of a VPC.
     */
    vpcId: string;
}

export interface GetCbrBackupChildren {
    /**
     * The restore point ID of the sub-backup resource.
     */
    checkpointId: string;
    /**
     * The creation time of the sub-backup.
     */
    createdAt: string;
    /**
     * The sub-backup description.
     */
    description: string;
    /**
     * The enterprise project to which the backup sub-backup resource belongs.
     */
    enterpriseProjectId: string;
    /**
     * The expiration time of the sub-backup.
     */
    expiredAt: string;
    /**
     * The extended information.
     */
    extendInfos: outputs.GetCbrBackupChildrenExtendInfo[];
    /**
     * The sub-backup ID.
     */
    id: string;
    /**
     * The sub-backup name.
     */
    name: string;
    /**
     * The replication records.
     */
    replicationRecords: outputs.GetCbrBackupChildrenReplicationRecord[];
    /**
     * The availability zone where the backup sub-backup resource is located.
     */
    resourceAz: string;
    /**
     * The sub-backup resource ID.
     */
    resourceId: string;
    /**
     * The sub-backup resource name.
     */
    resourceName: string;
    /**
     * The sub-backup resource size, in GB.
     */
    resourceSize: number;
    /**
     * The sub-backup resource type.
     */
    resourceType: string;
    /**
     * The sub-backup status.
     */
    status: string;
    /**
     * The sub-backup type.
     */
    type: string;
    /**
     * The latest update time of the sub-backup.
     */
    updatedAt: string;
    /**
     * The vault to which the backup sub-backup resource belongs.
     */
    vaultId: string;
}

export interface GetCbrBackupChildrenExtendInfo {
    /**
     * Whether the backup is automatically generated.
     */
    autoTrigger: boolean;
    /**
     * Whether the backup is a system disk backup.
     */
    bootable: boolean;
    /**
     * Whether the VM backup data contains system disk data.
     */
    containSystemDisk: boolean;
    /**
     * Whether the backup is encrypted.
     */
    encrypted: boolean;
    /**
     * Whether the backup is an incremental backup.
     */
    incremental: boolean;
    /**
     * Whether the disk is a system disk.
     */
    isSystemDisk: boolean;
    /**
     * The ID list of images created using backups.
     */
    osRegistryImages: string[];
    /**
     * Snapshot ID of the disk backup.
     */
    snapshotId: string;
    /**
     * Whether to allow lazyloading for fast restoration.
     */
    supportLld: boolean;
    /**
     * The restoration mode.
     */
    supportedRestoreMode: string;
}

export interface GetCbrBackupChildrenReplicationRecord {
    /**
     * The creation time of the replication.
     */
    createdAt: string;
    /**
     * The ID of the destination backup used for replication.
     */
    destinationBackupId: string;
    /**
     * The record ID of the destination backup used for replication.
     */
    destinationCheckpointId: string;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The replication destination region.
     */
    destinationRegion: string;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The additional information of the replication.
     */
    extraInfos: outputs.GetCbrBackupChildrenReplicationRecordExtraInfo[];
    /**
     * The replication record ID.
     */
    id: string;
    /**
     * The ID of the source backup used for replication.
     */
    sourceBackupId: string;
    /**
     * The ID of the source backup record used for replication.
     */
    sourceCheckpointId: string;
    /**
     * The ID of the replication source project.
     */
    sourceProjectId: string;
    /**
     * The replication source region.
     */
    sourceRegion: string;
    /**
     * The replication status.
     */
    status: string;
    /**
     * The ID of the vault where the backup resides.
     */
    vaultId: string;
}

export interface GetCbrBackupChildrenReplicationRecordExtraInfo {
    /**
     * Whether replication is automatically scheduled.
     */
    autoTrigger: boolean;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The error code.
     */
    failCode: string;
    /**
     * The error cause.
     */
    failReason: string;
    /**
     * The replication progress.
     */
    progress: number;
}

export interface GetCbrBackupExtendInfo {
    /**
     * Whether the backup is automatically generated.
     */
    autoTrigger: boolean;
    /**
     * Whether the backup is a system disk backup.
     */
    bootable: boolean;
    /**
     * Whether the VM backup data contains system disk data.
     */
    containSystemDisk: boolean;
    /**
     * Whether the backup is encrypted.
     */
    encrypted: boolean;
    /**
     * Whether the backup is an incremental backup.
     */
    incremental: boolean;
    /**
     * Whether the disk is a system disk.
     */
    isSystemDisk: boolean;
    /**
     * The ID list of images created using backups.
     */
    osRegistryImages: string[];
    /**
     * Snapshot ID of the disk backup.
     */
    snapshotId: string;
    /**
     * Whether to allow lazyloading for fast restoration.
     */
    supportLld: boolean;
    /**
     * The restoration mode.
     */
    supportedRestoreMode: string;
}

export interface GetCbrBackupReplicationRecord {
    /**
     * The creation time of the replication.
     */
    createdAt: string;
    /**
     * The ID of the destination backup used for replication.
     */
    destinationBackupId: string;
    /**
     * The record ID of the destination backup used for replication.
     */
    destinationCheckpointId: string;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The replication destination region.
     */
    destinationRegion: string;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The additional information of the replication.
     */
    extraInfos: outputs.GetCbrBackupReplicationRecordExtraInfo[];
    /**
     * The replication record ID.
     */
    id: string;
    /**
     * The ID of the source backup used for replication.
     */
    sourceBackupId: string;
    /**
     * The ID of the source backup record used for replication.
     */
    sourceCheckpointId: string;
    /**
     * The ID of the replication source project.
     */
    sourceProjectId: string;
    /**
     * The replication source region.
     */
    sourceRegion: string;
    /**
     * The replication status.
     */
    status: string;
    /**
     * The ID of the vault where the backup resides.
     */
    vaultId: string;
}

export interface GetCbrBackupReplicationRecordExtraInfo {
    /**
     * Whether replication is automatically scheduled.
     */
    autoTrigger: boolean;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The error code.
     */
    failCode: string;
    /**
     * The error cause.
     */
    failReason: string;
    /**
     * The replication progress.
     */
    progress: number;
}

export interface GetCbrPoliciesPolicy {
    /**
     * The vault associated with the CBR policy
     */
    associatedVaults: outputs.GetCbrPoliciesPolicyAssociatedVault[];
    /**
     * The scheduling rule for the CBR policy backup execution.
     */
    backupCycles: outputs.GetCbrPoliciesPolicyBackupCycle[];
    /**
     * The maximum number of retained backups.
     */
    backupQuantity: number;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The name of the replication destination region.
     */
    destinationRegion: string;
    /**
     * Whether to enable the acceleration function to shorten the replication time for cross-region
     */
    enableAcceleration: boolean;
    /**
     * Whether to enable the CBR policy.
     */
    enabled: boolean;
    /**
     * The policy ID.
     */
    id: string;
    /**
     * The long-term retention rules.
     */
    longTermRetentions: outputs.GetCbrPoliciesPolicyLongTermRetention[];
    /**
     * The policy name.
     */
    name: string;
    /**
     * The duration (in days) for retained backups.
     */
    timePeriod: number;
    /**
     * The UTC time zone.
     */
    timeZone: string;
    /**
     * The protection type of the CBR policy.
     */
    type: string;
}

export interface GetCbrPoliciesPolicyAssociatedVault {
    /**
     * The destination vault ID associated with CBR policy
     */
    destinationVaultId: string;
    /**
     * The vault ID of the associated CBR policy
     */
    vaultId: string;
}

export interface GetCbrPoliciesPolicyBackupCycle {
    /**
     * The weekly backup time.
     */
    days: string;
    /**
     * The execution time of the policy.
     */
    executionTimes: string[];
    /**
     * The number of days between each backup.
     */
    interval: number;
}

export interface GetCbrPoliciesPolicyLongTermRetention {
    /**
     * The latest backup of each day is saved in the long term.
     */
    daily: number;
    /**
     * How often (after how many incremental backups) a full backup is performed.
     */
    fullBackupInterval: number;
    /**
     * The latest backup of each month is saved in the long term.
     */
    monthly: number;
    /**
     * The latest backup of each week is saved in the long term.
     */
    weekly: number;
    /**
     * The latest backup of each year is saved in the long term.
     */
    yearly: number;
}

export interface GetCbrVaultsVault {
    /**
     * The allocated capacity of the vault, in GB.
     */
    allocated: number;
    /**
     * Whether automatic association is supported.
     */
    autoBind: boolean;
    /**
     * Whether to enable automatic expansion of the backup protection type vault.
     */
    autoExpandEnabled: boolean;
    /**
     * The rules for automatic association.
     */
    bindRules: {[key: string]: string};
    /**
     * The consistent level (specification) of the vault.
     */
    consistentLevel: string;
    /**
     * The enterprise project ID.
     */
    enterpriseProjectId: string;
    /**
     * The vault ID in UUID format.
     */
    id: string;
    /**
     * The vault name.
     */
    name: string;
    /**
     * The ID of the policy associated with the vault.
     */
    policyId: string;
    /**
     * The protection type of the vault.
     */
    protectionType: string;
    /**
     * The array of one or more resources to attach to the vault.
     */
    resources: outputs.GetCbrVaultsVaultResource[];
    /**
     * The vault capacity, in GB.
     */
    size: number;
    /**
     * The specification code.
     */
    specCode: string;
    /**
     * The vault status.
     */
    status: string;
    /**
     * The name of the bucket for the vault.
     */
    storage: string;
    /**
     * The key/value pairs to associate with the vault.
     */
    tags: {[key: string]: string};
    /**
     * The object type of the vault.
     */
    type: string;
    /**
     * The used capacity, in GB.
     */
    used: number;
}

export interface GetCbrVaultsVaultResource {
    /**
     * The array of disk IDs which will be excluded in the backup.
     */
    excludes: string[];
    /**
     * The array of disk or SFS file system IDs which will be included in the backup.
     */
    includes: string[];
    /**
     * The ID of the ECS instance to be backed up.
     */
    serverId: string;
}

export interface GetCceAddonTemplateSupportVersion {
    bareMetals: string[];
    virtualMachines: string[];
}

export interface GetCceClusterCertificateCluster {
    certificateAuthorityData: string;
    insecureSkipTlsVerify: boolean;
    name: string;
    server: string;
}

export interface GetCceClusterCertificateContext {
    cluster: string;
    name: string;
    user: string;
}

export interface GetCceClusterCertificateUser {
    clientCertificateData: string;
    clientKeyData: string;
    name: string;
}

export interface GetCceClusterEndpoint {
    type: string;
    url: string;
}

export interface GetCceClusterMaster {
    availabilityZone: string;
}

export interface GetCceClustersCluster {
    authenticationMode: string;
    billingMode: number;
    certificateClusters: outputs.GetCceClustersClusterCertificateCluster[];
    certificateUsers: outputs.GetCceClustersClusterCertificateUser[];
    clusterType: string;
    clusterVersion: string;
    containerNetworkCidr: string;
    containerNetworkType: string;
    description: string;
    endpoints: outputs.GetCceClustersClusterEndpoint[];
    eniSubnetCidr: string;
    eniSubnetId: string;
    enterpriseProjectId: string;
    flavorId: string;
    id: string;
    kubeConfigRaw: string;
    masters: outputs.GetCceClustersClusterMaster[];
    name: string;
    securityGroupId: string;
    serviceNetworkCidr: string;
    status: string;
    subnetId: string;
    vpcId: string;
}

export interface GetCceClustersClusterCertificateCluster {
    certificateAuthorityData: string;
    name: string;
    server: string;
}

export interface GetCceClustersClusterCertificateUser {
    clientCertificateData: string;
    clientKeyData: string;
    name: string;
}

export interface GetCceClustersClusterEndpoint {
    type: string;
    url: string;
}

export interface GetCceClustersClusterMaster {
    availabilityZone: string;
}

export interface GetCceNodeDataVolume {
    extendParams: {[key: string]: string};
    size: number;
    volumetype: string;
}

export interface GetCceNodeHostnameConfig {
    type: string;
}

export interface GetCceNodePoolDataVolume {
    extendParams: {[key: string]: string};
    size: number;
    volumetype: string;
}

export interface GetCceNodePoolHostnameConfig {
    type: string;
}

export interface GetCceNodePoolRootVolume {
    extendParams: {[key: string]: string};
    size: number;
    volumetype: string;
}

export interface GetCceNodeRootVolume {
    extendParams: {[key: string]: string};
    size: number;
    volumetype: string;
}

export interface GetCceNodesNode {
    availabilityZone: string;
    billingMode: number;
    dataVolumes: outputs.GetCceNodesNodeDataVolume[];
    ecsGroupId: string;
    enterpriseProjectId: string;
    flavorId: string;
    hostnameConfigs: outputs.GetCceNodesNodeHostnameConfig[];
    id: string;
    keyPair: string;
    name: string;
    os: string;
    privateIp: string;
    publicIp: string;
    rootVolumes: outputs.GetCceNodesNodeRootVolume[];
    serverId: string;
    status: string;
    subnetId: string;
    tags: {[key: string]: string};
}

export interface GetCceNodesNodeDataVolume {
    extendParams: {[key: string]: string};
    size: number;
    volumetype: string;
}

export interface GetCceNodesNodeHostnameConfig {
    type: string;
}

export interface GetCceNodesNodeRootVolume {
    extendParams: {[key: string]: string};
    size: number;
    volumetype: string;
}

export interface GetCdmFlavorsFlavor {
    cpu: string;
    id: string;
    memory: string;
    name: string;
}

export interface GetCfwAccessControlLogsRecord {
    /**
     * The action.
     */
    action: string;
    /**
     * The application protocol.
     */
    app: string;
    /**
     * The distination city ID.
     */
    dstCityId: string;
    /**
     * The distination city name.
     */
    dstCityName: string;
    /**
     * The destination host.
     */
    dstHost: string;
    /**
     * The destination IP address.
     */
    dstIp: string;
    /**
     * The destination port.
     */
    dstPort: number;
    /**
     * The distination province ID.
     */
    dstProvinceId: string;
    /**
     * The distination province name.
     */
    dstProvinceName: string;
    /**
     * The destination region ID.
     */
    dstRegionId: string;
    /**
     * The destination region name.
     */
    dstRegionName: string;
    /**
     * The hit time.
     */
    hitTime: string;
    /**
     * The document ID.
     */
    logId: string;
    /**
     * The protocol type.
     */
    protocol: string;
    /**
     * The rule ID.
     */
    ruleId: string;
    /**
     * The rule name.
     */
    ruleName: string;
    /**
     * The source city ID.
     */
    srcCityId: string;
    /**
     * The source city name.
     */
    srcCityName: string;
    /**
     * The source IP address.
     */
    srcIp: string;
    /**
     * The source port.
     */
    srcPort: number;
    /**
     * The source province ID.
     */
    srcProvinceId: string;
    /**
     * The source province name.
     */
    srcProvinceName: string;
    /**
     * The source region ID.
     */
    srcRegionId: string;
    /**
     * The source region name.
     */
    srcRegionName: string;
}

export interface GetCfwAddressGroupMembersRecord {
    /**
     * The IP address.
     */
    address: string;
    /**
     * The address type.
     */
    addressType: number;
    /**
     * The address group member description.
     */
    description: string;
    /**
     * The ID of an address group member.
     */
    itemId: string;
}

export interface GetCfwAddressGroupsAddressGroup {
    /**
     * The address type.
     */
    addressType: number;
    /**
     * The address groups description.
     */
    description: string;
    /**
     * The ID of the IP address group.
     */
    id: string;
    /**
     * The IP address group name.
     */
    name: string;
    /**
     * The protected object ID.
     */
    objectId: string;
    /**
     * The number of times this address group has been referenced.
     */
    refCount: number;
    /**
     * The address group type.
     */
    type: number;
}

export interface GetCfwAttackLogsRecord {
    /**
     * Then action.
     */
    action: string;
    /**
     * The application protocol.
     */
    app: string;
    /**
     * The attack rule.
     */
    attackRule: string;
    /**
     * The attack rule ID.
     */
    attackRuleId: string;
    /**
     * The attack type.
     */
    attackType: string;
    /**
     * The direction.
     */
    direction: string;
    /**
     * The distination city ID.
     */
    dstCityId: string;
    /**
     * The distination city name.
     */
    dstCityName: string;
    /**
     * The destination IP address.
     */
    dstIp: string;
    /**
     * The destination port.
     */
    dstPort: number;
    /**
     * The distination province ID.
     */
    dstProvinceId: string;
    /**
     * The distination province name.
     */
    dstProvinceName: string;
    /**
     * The destination region ID.
     */
    dstRegionId: string;
    /**
     * The destination region name.
     */
    dstRegionName: string;
    /**
     * The event time.
     */
    eventTime: string;
    /**
     * The threat level.
     */
    level: string;
    /**
     * The log ID.
     */
    logId: string;
    /**
     * The attack log packet.
     */
    packet: string;
    /**
     * The packet length.
     */
    packetLength: number;
    /**
     * The packet messages.
     */
    packetMessages: outputs.GetCfwAttackLogsRecordPacketMessage[];
    /**
     * The protocol.
     */
    protocol: string;
    /**
     * The source.
     */
    source: string;
    /**
     * The source city ID.
     */
    srcCityId: string;
    /**
     * The source city name.
     */
    srcCityName: string;
    /**
     * The source IP address.
     */
    srcIp: string;
    /**
     * The source port.
     */
    srcPort: number;
    /**
     * The source province ID.
     */
    srcProvinceId: string;
    /**
     * The source province name.
     */
    srcProvinceName: string;
    /**
     * The source region ID.
     */
    srcRegionId: string;
    /**
     * The source region name.
     */
    srcRegionName: string;
}

export interface GetCfwAttackLogsRecordPacketMessage {
    /**
     * The hexadecimal index.
     */
    hexIndex: string;
    /**
     * The hexadecimal series.
     */
    hexs: string[];
    /**
     * The utf-8 string.
     */
    utf8String: string;
}

export interface GetCfwBlackWhiteListsRecord {
    /**
     * The IP address.
     */
    address: string;
    /**
     * The IP address type.
     */
    addressType: string;
    /**
     * The description.
     */
    description: string;
    /**
     * The direction of a black or white address.
     */
    direction: string;
    /**
     * The blacklist/whitelist ID.
     */
    listId: string;
    /**
     * The port.
     */
    port: string;
    /**
     * The protocol type.
     */
    protocol: number;
}

export interface GetCfwCaptureTaskResultsFileList {
    /**
     * The file name.
     */
    fileName: string;
    /**
     * The file path.
     */
    filePath: string;
    /**
     * The download link.
     */
    url: string;
}

export interface GetCfwCaptureTaskResultsRequestHeader {
    /**
     * The host header information.
     */
    host: string;
}

export interface GetCfwCaptureTasksRecord {
    /**
     * The capture task size.
     */
    captureSize: string;
    /**
     * The creation time of the capture task.
     */
    createdAt: string;
    /**
     * The destination address.
     */
    destAddress: string;
    /**
     * The destination address type.
     */
    destAddressType: number;
    /**
     * The destination port.
     */
    destPort: string;
    /**
     * The capture task duration.
     */
    duration: number;
    /**
     * Whether is deleted.
     */
    isDeleted: number;
    /**
     * The max packets.
     */
    maxPackets: number;
    /**
     * The capture task name.
     */
    name: string;
    /**
     * The protocol type.
     */
    protocol: number;
    /**
     * The remaining days.
     */
    remainingDays: number;
    /**
     * The source address.
     */
    sourceAddress: string;
    /**
     * The source address type.
     */
    sourceAddressType: number;
    /**
     * The source port.
     */
    sourcePort: string;
    /**
     * The capture task status.
     */
    status: number;
    /**
     * The capture task ID.
     */
    taskId: string;
    /**
     * The update time of the capture task.
     */
    updatedAt: string;
}

export interface GetCfwDomainNameGroupsRecord {
    /**
     * The configuration status.
     */
    configStatus: string;
    /**
     * The domain name group description.
     */
    description: string;
    /**
     * The list of domain names.
     */
    domainNames: outputs.GetCfwDomainNameGroupsRecordDomainName[];
    /**
     * The domain name group ID.
     */
    groupId: string;
    /**
     * The configuration message.
     */
    message: string;
    /**
     * The domain name group name.
     */
    name: string;
    /**
     * The domain name group reference count.
     */
    refCount: string;
    /**
     * The used rule list.
     */
    rules: outputs.GetCfwDomainNameGroupsRecordRule[];
    /**
     * The domain name group type.
     */
    type: string;
}

export interface GetCfwDomainNameGroupsRecordDomainName {
    /**
     * The description.
     */
    description: string;
    /**
     * The domain address ID.
     */
    domainAddressId: string;
    /**
     * The domain name.
     */
    domainName: string;
}

export interface GetCfwDomainNameGroupsRecordRule {
    /**
     * The rule ID.
     */
    id: string;
    /**
     * The rule name.
     */
    name: string;
}

export interface GetCfwFirewallsRecord {
    /**
     * Billing mode. The value can be 0 (yearly/monthly) or 1 (pay-per-use).
     */
    chargeMode: number;
    /**
     * Engine type
     */
    engineType: number;
    /**
     * Whether to enable the feature. The options are true (yes) and false (no).
     */
    featureToggle: {[key: string]: boolean};
    /**
     * The flavor of the firewall.
     */
    flavors: outputs.GetCfwFirewallsRecordFlavor[];
    /**
     * Firewall ID
     */
    fwInstanceId: string;
    /**
     * Cluster type
     */
    haType: number;
    /**
     * Whether the engine is an old engine. The options are true (yes) and false (no).
     */
    isOldFirewallInstance: boolean;
    /**
     * Firewall name
     */
    name: string;
    /**
     * Project list
     */
    protectObjects: outputs.GetCfwFirewallsRecordProtectObject[];
    /**
     * Firewall instance resources
     */
    resources: outputs.GetCfwFirewallsRecordResource[];
    /**
     * Service type
     */
    serviceType: number;
    /**
     * Firewall status list. The options are as follows: -1: waiting for payment; 0: creating; 1: deleting; 2: running; 3: upgrading; 4: deletion completed; 5: freezing; 6: creation failed; 7: deletion failed; 8: freezing failed; 9: storage in progress; 10: storage failed; 11: upgrade failed
     */
    status: number;
    /**
     * Whether IPv6 is supported. The options are true (yes) and false (no).
     */
    supportIpv6: boolean;
}

export interface GetCfwFirewallsRecordFlavor {
    /**
     * Bandwidth
     */
    bandwidth: number;
    /**
     * Number of EIPs
     */
    eipCount: number;
    /**
     * Log storage
     */
    logStorage: number;
    /**
     * Firewall version. The value can be 0 (standard edition), 1 (professional edition), 2 (platinum edition), or 3 (basic edition).
     */
    version: number;
    /**
     * Number of VPCs
     */
    vpcCount: number;
}

export interface GetCfwFirewallsRecordProtectObject {
    /**
     * Protected object ID
     */
    objectId: string;
    /**
     * Protected object name
     */
    objectName: string;
    /**
     * Project type. The options are as follows: 0: north-south; 1: east-west.
     */
    type: number;
}

export interface GetCfwFirewallsRecordResource {
    /**
     * Service type, which is used by CBC. The value is hws.service.type.cfw.
     */
    cloudServiceType: string;
    /**
     * Resource ID
     */
    resourceId: string;
    /**
     * Resource quantity
     */
    resourceSize: number;
    /**
     * Resource unit name
     */
    resourceSizeMeasureId: number;
    /**
     * Inventory unit code
     */
    resourceSpecCode: string;
    /**
     * Resource type. The options are as follows:1. CFW: hws.resource.type.cfw 2. EIP:hws.resource.type.cfw.exp.eip 3. Bandwidth: hws.resource.type.cfw.exp.bandwidth 4. VPC: hws.resource.type.cfw.exp.vpc 5. Log storage: hws.resource.type.cfw.exp.logaudit
     */
    resourceType: string;
}

export interface GetCfwFlowLogsRecord {
    /**
     * The application protocol.
     */
    app: string;
    /**
     * The flow log bytes.
     */
    bytes: number;
    /**
     * The direction, which can be inbound or outbound.
     */
    direction: string;
    /**
     * The distination city ID.
     */
    dstCityId: string;
    /**
     * The distination city name.
     */
    dstCityName: string;
    /**
     * The destination host.
     */
    dstHost: string;
    /**
     * The destination IP address.
     */
    dstIp: string;
    /**
     * The destination port.
     */
    dstPort: number;
    /**
     * The distination province ID.
     */
    dstProvinceId: string;
    /**
     * The distination province name.
     */
    dstProvinceName: string;
    /**
     * The destination region id.
     */
    dstRegionId: string;
    /**
     * The destination region name.
     */
    dstRegionName: string;
    /**
     * The end time.
     */
    endTime: string;
    /**
     * The document ID.
     */
    logId: string;
    /**
     * The number of packets.
     */
    packets: number;
    /**
     * The protocol type.
     */
    protocol: string;
    /**
     * The source city ID.
     */
    srcCityId: string;
    /**
     * The source city name.
     */
    srcCityName: string;
    /**
     * The source IP address.
     */
    srcIp: string;
    /**
     * The source port.
     */
    srcPort: number;
    /**
     * The source province ID.
     */
    srcProvinceId: string;
    /**
     * The source province name.
     */
    srcProvinceName: string;
    /**
     * The source region id.
     */
    srcRegionId: string;
    /**
     * The source region name.
     */
    srcRegionName: string;
    /**
     * The start time.
     */
    startTime: string;
}

export interface GetCfwIpsCustomRulesRecord {
    /**
     * The action.
     */
    action: number;
    /**
     * The affected OS.
     */
    affectedOs: number;
    /**
     * The attack type.
     */
    attackType: number;
    /**
     * The rule status.
     */
    configStatus: number;
    /**
     * The content storage in JSON format.
     */
    content: string;
    /**
     * The destination port type.
     */
    dstPortType: number;
    /**
     * The destination port.
     */
    dstPorts: string;
    /**
     * The firewall cluster ID.
     */
    groupId: string;
    /**
     * The ID of a custom IPS rule in CFW.
     */
    ipsCfwId: string;
    /**
     * The ID of a rule in Hillstone.
     */
    ipsId: string;
    /**
     * The IPS rule name.
     */
    ipsName: string;
    /**
     * The protocol.
     */
    protocol: number;
    /**
     * The severity.
     */
    severity: number;
    /**
     * The affected software.
     */
    software: number;
    /**
     * The source port type.
     */
    srcPortType: number;
    /**
     * The source port.
     */
    srcPorts: string;
}

export interface GetCfwIpsRuleDetailsData {
    /**
     * The IPS type.
     */
    ipsType: number;
    /**
     * The IPS version.
     */
    ipsVersion: string;
    /**
     * The update time.
     */
    updateTime: string;
}

export interface GetCfwIpsRulesRecord {
    /**
     * The application affected by the rule.
     */
    affectedApplication: string;
    /**
     * The creation time.
     */
    createTime: string;
    /**
     * The default status of the IPS rule.
     */
    defaultStatus: string;
    /**
     * The CVE.
     */
    ipsCve: string;
    /**
     * The IPS rule group.
     */
    ipsGroup: string;
    /**
     * The IPS rule ID.
     */
    ipsId: string;
    /**
     * The risk level.
     */
    ipsLevel: string;
    /**
     * The IPS rule name.
     */
    ipsName: string;
    /**
     * The IPS rule type.
     */
    ipsRulesType: string;
    /**
     * The current status of the IPS rule.
     */
    ipsStatus: string;
}

export interface GetCfwProtectionRulesRecord {
    /**
     * The rule action type.
     */
    actionType: string;
    /**
     * The address type.
     */
    addressType: number;
    /**
     * The created time of a rule.
     */
    createdDate: string;
    /**
     * The rule description.
     */
    description: string;
    /**
     * The destination configuration.
     */
    destinations: outputs.GetCfwProtectionRulesRecordDestination[];
    /**
     * The direction of a rule.
     */
    direction: string;
    /**
     * The last open time.
     */
    lastOpenTime: string;
    /**
     * Whether to support persistent connections.
     */
    longConnectEnable: number;
    /**
     * The persistent connection duration.
     */
    longConnectTime: number;
    /**
     * The persistent connection duration (hour).
     */
    longConnectTimeHour: number;
    /**
     * The persistent connection duration (minute).
     */
    longConnectTimeMinute: number;
    /**
     * The persistent connection duration (second).
     */
    longConnectTimeSecond: number;
    /**
     * The rule name.
     */
    name: string;
    /**
     * The rule ID.
     */
    ruleId: string;
    /**
     * The service.
     */
    services: outputs.GetCfwProtectionRulesRecordService[];
    /**
     * The source configuration.
     */
    sources: outputs.GetCfwProtectionRulesRecordSource[];
    /**
     * The rule status.
     */
    status: string;
    /**
     * The tag of a rule.
     */
    tags: {[key: string]: string};
    /**
     * The rule type.
     */
    type: string;
}

export interface GetCfwProtectionRulesRecordDestination {
    /**
     * The destination IP address.
     */
    address: string;
    /**
     * The address group.
     */
    addressGroups: string[];
    /**
     * The ID of the associated IP address group.
     */
    addressSetId: string;
    /**
     * The IP address group name.
     */
    addressSetName: string;
    /**
     * The destination address set type.
     */
    addressSetType: number;
    /**
     * The destination address type.
     */
    addressType: number;
    /**
     * The name of the domain name address.
     */
    domainAddressName: string;
    /**
     * The ID of the domain group.
     */
    domainSetId: string;
    /**
     * The name of domain group.
     */
    domainSetName: string;
    /**
     * The IP address list.
     */
    ipAddresses: string[];
    /**
     * The region list of a rule.
     */
    regionLists: outputs.GetCfwProtectionRulesRecordDestinationRegionList[];
    /**
     * The destination type.
     */
    type: number;
}

export interface GetCfwProtectionRulesRecordDestinationRegionList {
    /**
     * The Chinese description of a region.
     */
    descriptionCn: string;
    /**
     * The English description of a region.
     */
    descriptionEn: string;
    /**
     * The region ID of the destination.
     */
    regionId: string;
    /**
     * The region type.
     */
    regionType: number;
}

export interface GetCfwProtectionRulesRecordService {
    /**
     * The custom service.
     */
    customServices: outputs.GetCfwProtectionRulesRecordServiceCustomService[];
    /**
     * The destination port of the service.
     */
    destPort: string;
    /**
     * The protocol type.
     */
    protocol: number;
    /**
     * The protocols.
     */
    protocols: number[];
    /**
     * The service group list.
     */
    serviceGroups: string[];
    /**
     * The service group ID.
     */
    serviceSetId: string;
    /**
     * The service group name.
     */
    serviceSetName: string;
    /**
     * The service set type.
     */
    serviceSetType: number;
    /**
     * The source port.
     */
    sourcePort: string;
    /**
     * The service input type.
     */
    type: number;
}

export interface GetCfwProtectionRulesRecordServiceCustomService {
    /**
     * The custom service description.
     */
    description: string;
    /**
     * The destination port.
     */
    destPort: string;
    /**
     * The custom service name.
     */
    name: string;
    /**
     * The protocol type of the custom service.
     */
    protocol: number;
    /**
     * The source port of the custom service.
     */
    sourcePort: string;
}

export interface GetCfwProtectionRulesRecordSource {
    /**
     * The source IP address.
     */
    address: string;
    /**
     * The address group.
     */
    addressGroups: string[];
    /**
     * The ID of the associated IP address group.
     */
    addressSetId: string;
    /**
     * The IP address group name.
     */
    addressSetName: string;
    /**
     * The address set type.
     */
    addressSetType: number;
    /**
     * The address type.
     */
    addressType: number;
    /**
     * The name of the domain address.
     */
    domainAddressName: string;
    /**
     * The IP address list.
     */
    ipAddresses: string[];
    /**
     * The region list of a rule.
     */
    regionLists: outputs.GetCfwProtectionRulesRecordSourceRegionList[];
    /**
     * The source type.
     */
    type: number;
}

export interface GetCfwProtectionRulesRecordSourceRegionList {
    /**
     * The Chinese description of a region.
     */
    descriptionCn: string;
    /**
     * The English description of a region.
     */
    descriptionEn: string;
    /**
     * The region ID.
     */
    regionId: string;
    /**
     * The region type.
     */
    regionType: number;
}

export interface GetCfwResourceTagsTag {
    /**
     * The tag key.
     */
    key: string;
    /**
     * The tag value.
     */
    value: string;
}

export interface GetCfwServiceGroupMembersRecord {
    /**
     * The service group member description.
     */
    description: string;
    /**
     * The destination port.
     */
    destPort: string;
    /**
     * The service group member ID.
     */
    itemId: string;
    /**
     * The protocol type.
     */
    protocol: number;
    /**
     * The source port.
     */
    sourcePort: string;
}

export interface GetCfwServiceGroupsServiceGroup {
    /**
     * The description of the service group.
     */
    description: string;
    /**
     * The service group ID.
     */
    id: string;
    /**
     * The name of the service group.
     */
    name: string;
    /**
     * The protocols of the service group.
     */
    protocols: number[];
    /**
     * The number of times this service group has been referenced.
     */
    refCount: number;
    /**
     * The type of the Service group.
     */
    type: number;
}

export interface GetCfwTagsTag {
    /**
     * The tag key.
     */
    key: string;
    /**
     * The tag values.
     */
    values: string[];
}

export interface GetComputeFlavorsFlavor {
    cpuCoreCount: number;
    generation: string;
    id: string;
    memorySize: number;
    performanceType: string;
    storageType: string;
}

export interface GetComputeInstanceNetwork {
    fixedIpV4: string;
    fixedIpV6: string;
    mac: string;
    port: string;
    uuid: string;
}

export interface GetComputeInstanceSchedulerHint {
    group: string;
}

export interface GetComputeInstanceVolumeAttached {
    bootIndex: number;
    isSysVolume: boolean;
    pciAddress: string;
    size: number;
    type: string;
    volumeId: string;
}

export interface GetComputeInstancesInstance {
    availabilityZone: string;
    chargingMode: string;
    enterpriseProjectId: string;
    expiredTime: string;
    flavorId: string;
    flavorName: string;
    id: string;
    imageId: string;
    imageName: string;
    keyPair: string;
    name: string;
    networks: outputs.GetComputeInstancesInstanceNetwork[];
    publicIp: string;
    schedulerHints: outputs.GetComputeInstancesInstanceSchedulerHint[];
    securityGroupIds: string[];
    status: string;
    systemDiskId: string;
    tags: {[key: string]: string};
    userData: string;
    volumeAttacheds: outputs.GetComputeInstancesInstanceVolumeAttached[];
}

export interface GetComputeInstancesInstanceNetwork {
    fixedIpV4: string;
    fixedIpV6: string;
    mac: string;
    port: string;
    uuid: string;
}

export interface GetComputeInstancesInstanceSchedulerHint {
    group: string;
}

export interface GetComputeInstancesInstanceVolumeAttached {
    bootIndex: number;
    isSysVolume: boolean;
    pciAddress: string;
    size: number;
    type: string;
    volumeId: string;
}

export interface GetComputeServergroupsServergroup {
    id: string;
    members: string[];
    name: string;
    policies: string[];
}

export interface GetCssFlavorsFlavor {
    availabilityZones: string;
    diskRange: string;
    id: string;
    memory: number;
    name: string;
    region: string;
    type: string;
    vcpus: number;
    version: string;
}

export interface GetDcsAccountsAccount {
    /**
     * Account name.
     */
    accountName: string;
    /**
     * Account permissions.
     */
    accountRole: string;
    /**
     * Account type.
     */
    accountType: string;
    /**
     * Account description.
     */
    description: string;
    /**
     * Account ID.
     */
    id: string;
    /**
     * Account status.
     */
    status: string;
}

export interface GetDcsFlavorsFlavor {
    availableZones: string[];
    cacheMode: string;
    capacity: number;
    chargingModes: string[];
    cpuArchitecture: string;
    engine: string;
    engineVersions: string;
    ipCount: number;
    name: string;
}

export interface GetDdsFlavorsFlavor {
    memory: string;
    specCode: string;
    type: string;
    vcpus: string;
}

export interface GetDmsKafkaConsumerGroupsGroup {
    /**
     * Indicates the partition assignment strategy.
     */
    assignmentStrategy: string;
    /**
     * Indicates the coordinator ID.
     */
    coordinatorId: number;
    /**
     * Indicates the create time.
     */
    createdAt: string;
    /**
     * Indicates the consumer group description.
     */
    description: string;
    /**
     * Indicates the group message offsets.
     */
    groupMessageOffsets: outputs.GetDmsKafkaConsumerGroupsGroupGroupMessageOffset[];
    /**
     * Indicates the number of accumulated messages.
     */
    lag: number;
    /**
     * Indicates the consumer group members.
     */
    members: outputs.GetDmsKafkaConsumerGroupsGroupMember[];
    /**
     * Indicates the consumer group name.
     */
    name: string;
    /**
     * Indicates the consumer group status.
     */
    state: string;
}

export interface GetDmsKafkaConsumerGroupsGroupGroupMessageOffset {
    /**
     * Indicates the number of accumulated messages.
     */
    lag: number;
    /**
     * Indicates the message current offset.
     */
    messageCurrentOffset: number;
    /**
     * Indicates the message log end offset.
     */
    messageLogEndOffset: number;
    /**
     * Indicates the partition.
     */
    partition: number;
    /**
     * Indicates the topic name.
     */
    topic: string;
}

export interface GetDmsKafkaConsumerGroupsGroupMember {
    /**
     * Indicates the details about the partition assigned to the consumer.
     */
    assignments: outputs.GetDmsKafkaConsumerGroupsGroupMemberAssignment[];
    /**
     * Indicates the client ID.
     */
    clientId: string;
    /**
     * Indicates the consumer address.
     */
    host: string;
    /**
     * Indicates the member ID.
     */
    memberId: string;
}

export interface GetDmsKafkaConsumerGroupsGroupMemberAssignment {
    /**
     * Indicates the partitions.
     */
    partitions: number[];
    /**
     * Indicates the topic name.
     */
    topic: string;
}

export interface GetDmsKafkaFlavorsFlavor {
    archTypes: string[];
    chargingModes: string[];
    id: string;
    ios: outputs.GetDmsKafkaFlavorsFlavorIo[];
    properties: outputs.GetDmsKafkaFlavorsFlavorProperty[];
    supportFeatures: outputs.GetDmsKafkaFlavorsFlavorSupportFeature[];
    type: string;
    vmSpecification: string;
}

export interface GetDmsKafkaFlavorsFlavorIo {
    availabilityZones: string[];
    storageSpecCode: string;
    type: string;
    unavailabilityZones: string[];
}

export interface GetDmsKafkaFlavorsFlavorProperty {
    flavorAlias: string;
    maxBandwidthPerBroker: number;
    maxBroker: number;
    maxConsumerPerBroker: number;
    maxPartitionPerBroker: number;
    maxStoragePerNode: number;
    maxTpsPerBroker: number;
    minBroker: number;
    minStoragePerNode: number;
}

export interface GetDmsKafkaFlavorsFlavorSupportFeature {
    name: string;
    properties: outputs.GetDmsKafkaFlavorsFlavorSupportFeatureProperty[];
}

export interface GetDmsKafkaFlavorsFlavorSupportFeatureProperty {
    maxNode: number;
    maxTask: number;
    minNode: number;
    minTask: number;
}

export interface GetDmsKafkaInstancesInstance {
    accessUser: string;
    availabilityZones: string[];
    connectAddress: string;
    crossVpcAccesses: outputs.GetDmsKafkaInstancesInstanceCrossVpcAccess[];
    description: string;
    dumping: boolean;
    enableAutoTopic: boolean;
    enablePublicIp: boolean;
    enabledMechanisms: string[];
    engineVersion: string;
    enterpriseProjectId: string;
    id: string;
    maintainBegin: string;
    maintainEnd: string;
    managementConnectAddress: string;
    managerUser: string;
    /**
     * @deprecated typo in manegement_connect_address, please use "managementConnectAddress" instead.
     */
    manegementConnectAddress: string;
    name: string;
    networkId: string;
    partitionNum: number;
    port: number;
    productId: string;
    publicConnAddresses: string;
    publicIpIds: string[];
    resourceSpecCode: string;
    retentionPolicy: string;
    securityGroupId: string;
    securityProtocol: string;
    sslEnable: boolean;
    status: string;
    storageSpace: number;
    storageSpecCode: string;
    tags: {[key: string]: string};
    type: string;
    usedStorageSpace: number;
    userId: string;
    userName: string;
    vpcId: string;
}

export interface GetDmsKafkaInstancesInstanceCrossVpcAccess {
    advertisedIp: string;
    /**
     * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
     */
    lisenterIp: string;
    listenerIp: string;
    port: number;
    portId: string;
}

export interface GetDmsKafkaMessagesMessage {
    /**
     * Indicates the application ID.
     */
    appId: string;
    /**
     * Indicates the big data flag.
     */
    hugeMessage: boolean;
    /**
     * Indicates the message key.
     */
    key: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
    /**
     * Indicates the message offset.
     */
    messageOffset: number;
    /**
     * Indicates the partition where the message is located.
     */
    partition: number;
    /**
     * Indicates the message size.
     */
    size: number;
    /**
     * Indicates the message label.
     */
    tag: string;
    /**
     * Indicates the message production time.
     */
    timestamp: string;
    /**
     * Indicates the message content.
     */
    value: string;
}

export interface GetDmsKafkaUsersUser {
    /**
     * Indicates the create time.
     */
    createdAt: string;
    /**
     * Indicates whether the application is the default application.
     */
    defaultApp: boolean;
    /**
     * Indicates the description.
     */
    description: string;
    /**
     * Indicates the username.
     */
    name: string;
    /**
     * Indicates the user role.
     */
    role: string;
}

export interface GetDmsRabbitmqFlavorsFlavor {
    archTypes: string[];
    chargingModes: string[];
    id: string;
    ios: outputs.GetDmsRabbitmqFlavorsFlavorIo[];
    properties: outputs.GetDmsRabbitmqFlavorsFlavorProperty[];
    supportFeatures: outputs.GetDmsRabbitmqFlavorsFlavorSupportFeature[];
    type: string;
    vmSpecification: string;
}

export interface GetDmsRabbitmqFlavorsFlavorIo {
    availabilityZones: string[];
    storageSpecCode: string;
    type: string;
    unavailabilityZones: string[];
}

export interface GetDmsRabbitmqFlavorsFlavorProperty {
    flavorAlias: string;
    maxBandwidthPerBroker: number;
    maxBroker: number;
    maxConsumerPerBroker: number;
    maxPartitionPerBroker: number;
    maxStoragePerNode: number;
    maxTpsPerBroker: number;
    minBroker: number;
    minStoragePerNode: number;
}

export interface GetDmsRabbitmqFlavorsFlavorSupportFeature {
    name: string;
    properties: outputs.GetDmsRabbitmqFlavorsFlavorSupportFeatureProperty[];
}

export interface GetDmsRabbitmqFlavorsFlavorSupportFeatureProperty {
    maxNode: number;
    maxTask: number;
    minNode: number;
    minTask: number;
}

export interface GetDmsRocketmqConsumerGroupAccessUsersPolicy {
    /**
     * Indicates the user name.
     */
    accessKey: string;
    /**
     * Indicates whether the user is an administrator.
     */
    admin: boolean;
    /**
     * Indicates the permissions.
     */
    perm: string;
    /**
     * Indicates the IP address whitelist.
     */
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqConsumerGroupsGroup {
    broadcast: boolean;
    brokers: string[];
    description: string;
    enabled: boolean;
    name: string;
    retryMaxTimes: number;
}

export interface GetDmsRocketmqConsumersClient {
    /**
     * Indicates the client address.
     */
    clientAddress: string;
    /**
     * Indicates the client ID.
     */
    clientId: string;
    /**
     * Indicates the client language.
     */
    language: string;
    /**
     * Indicates the subscription list.
     */
    subscriptions: outputs.GetDmsRocketmqConsumersClientSubscription[];
    /**
     * Indicates the client version.
     */
    version: string;
}

export interface GetDmsRocketmqConsumersClientSubscription {
    /**
     * Indicates the subscription tag.
     */
    expression: string;
    /**
     * Indicates the name of the subscribed topic.
     */
    topic: string;
    /**
     * Indicates the subscription type.
     */
    type: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavor {
    /**
     * Indicates the list of supported CPU architectures.
     */
    archTypes: string[];
    /**
     * Indicates the AZs where there are available resources.
     */
    availableZones: string[];
    /**
     * Indicates the billing code.
     */
    billingCode: string;
    /**
     * Indicates the list of supported billing modes.
     */
    chargingModes: string[];
    /**
     * Indicates the flavor ID.
     */
    id: string;
    /**
     * Indicates the list of supported disk IO types.
     */
    ios: outputs.GetDmsRocketmqExtendFlavorsFlavorIo[];
    /**
     * Indicates the properties of the current specification.
     */
    properties: outputs.GetDmsRocketmqExtendFlavorsFlavorProperty[];
    /**
     * Indicates the supported features.
     */
    supportFeatures: outputs.GetDmsRocketmqExtendFlavorsFlavorSupportFeature[];
    /**
     * Indicates the flavor type.
     */
    type: string;
    /**
     * Indicates the AZs where resources are unavailable.
     */
    unavailableZones: string[];
    /**
     * Indicates the underlying VM specification.
     */
    vmSpecification: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavorIo {
    /**
     * Indicates the list of availability zones with available resources.
     */
    availableZones: string[];
    /**
     * Indicates the disk IO encoding.
     */
    storageSpecCode: string;
    /**
     * Indicates the disk type.
     */
    type: string;
    /**
     * Indicates the list of unavailability zones with available resources.
     */
    unavailableZones: string[];
}

export interface GetDmsRocketmqExtendFlavorsFlavorProperty {
    /**
     * Indicates the version of the message engine.
     */
    engineVersions: string;
    /**
     * Indicates the alias of **flavor_id**.
     */
    flavorAlias: string;
    /**
     * Indicates the maximum number of brokers.
     */
    maxBroker: string;
    /**
     * Indicates the maximum number of consumers of each broker.
     */
    maxConsumerPerBroker: string;
    /**
     * Indicates the maximum storage space of each broker. Unit: GB.
     */
    maxStoragePerNode: string;
    /**
     * Indicates the maximum number of topics that can be created on each broker.
     */
    maxTopicPerBroker: string;
    /**
     * Indicates the minimum number of brokers.
     */
    minBroker: string;
    /**
     * Indicates the minimum storage space of each broker. Unit: GB.
     */
    minStoragePerNode: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavorSupportFeature {
    /**
     * Indicates the feature name.
     */
    name: string;
    /**
     * Indicates the key-value pair of a feature.
     */
    properties: {[key: string]: string};
}

export interface GetDmsRocketmqFlavorsFlavor {
    /**
     * Indicates the list of the types of CPU architecture.
     */
    archTypes: string[];
    /**
     * Indicates the list of the billing modes.
     */
    chargingModes: string[];
    /**
     * Indicates the ID of the flavor.
     */
    id: string;
    /**
     * Indicates the list of disk IO types.
     */
    ios: outputs.GetDmsRocketmqFlavorsFlavorIo[];
    /**
     * Indicates the list of the properties of the current specification.
     */
    properties: outputs.GetDmsRocketmqFlavorsFlavorProperty[];
    /**
     * Indicates the list of features supported by the current specification.
     */
    supportFeatures: outputs.GetDmsRocketmqFlavorsFlavorSupportFeature[];
    /**
     * Indicates the type of the flavor.
     */
    type: string;
    /**
     * Indicates the underlying VM specification.
     */
    vmSpecification: string;
}

export interface GetDmsRocketmqFlavorsFlavorIo {
    /**
     * Indicates the list of availability zone names.
     */
    availabilityZones: string[];
    /**
     * Indicates the disk IO encoding.
     */
    storageSpecCode: string;
    /**
     * Indicates the disk type.
     */
    type: string;
    /**
     * Indicates the list of unavailability zone names.
     */
    unavailabilityZones: string[];
}

export interface GetDmsRocketmqFlavorsFlavorProperty {
    /**
     * Indicates the alias of the flavor.
     */
    flavorAlias: string;
    /**
     * Indicates the maximum bandwidth per broker.
     */
    maxBandwidthPerBroker: number;
    /**
     * Indicates the maximum number of brokers.
     */
    maxBroker: number;
    /**
     * Indicates the maximum number of consumers per broker.
     */
    maxConsumerPerBroker: number;
    /**
     * Indicates the maximum number of partitions per broker.
     */
    maxPartitionPerBroker: number;
    /**
     * Indicates the maximum storage per node. The unit is GB.
     */
    maxStoragePerNode: number;
    /**
     * Indicates the maximum TPS per broker.
     */
    maxTpsPerBroker: number;
    /**
     * Indicates the minimum number of brokers.
     */
    minBroker: number;
    /**
     * Indicates the minimum storage per node. The unit is GB.
     */
    minStoragePerNode: number;
}

export interface GetDmsRocketmqFlavorsFlavorSupportFeature {
    /**
     * Indicates the function name.
     */
    name: string;
    /**
     * Indicates the list of the function property details.
     */
    properties: outputs.GetDmsRocketmqFlavorsFlavorSupportFeatureProperty[];
}

export interface GetDmsRocketmqFlavorsFlavorSupportFeatureProperty {
    /**
     * Indicates the maximum number of nodes for the dump function.
     */
    maxNode: number;
    /**
     * Indicates the maximum number of tasks for the dump function.
     */
    maxTask: number;
    /**
     * Indicates the minimum number of nodes for the dump function.
     */
    minNode: number;
    /**
     * Indicates the minimum number of tasks for the dump function.
     */
    minTask: number;
}

export interface GetDmsRocketmqInstancesInstance {
    /**
     * Indicates the list of availability zone names.
     */
    availabilityZones: string[];
    /**
     * Indicates the service data address.
     */
    brokerAddress: string;
    /**
     * Indicates the broker numbers.
     */
    brokerNum: number;
    /**
     * Indicates the Cross-VPC access information.
     */
    crossVpcAccesses: outputs.GetDmsRocketmqInstancesInstanceCrossVpcAccess[];
    /**
     * Indicates the description of the DMS RocketMQ instance.
     */
    description: string;
    /**
     * Indicates whether access control is enabled.
     */
    enableAcl: boolean;
    /**
     * Indicates whether to enable public access.
     */
    enablePublicip: boolean;
    /**
     * Indicates the version of the RocketMQ engine.
     */
    engineVersion: string;
    /**
     * Indicates a product ID.
     */
    flavorId: string;
    /**
     * Indicates the ID of the DMS RocketMQ instance.
     */
    id: string;
    /**
     * Indicates whether to support IPv6.
     */
    ipv6Enable: boolean;
    /**
     * Indicates the time at which the maintenance window starts. The format is HH:mm:ss.
     */
    maintainBegin: string;
    /**
     * Indicates the time at which the maintenance window ends. The format is HH:mm:ss.
     */
    maintainEnd: string;
    /**
     * Indicates the name of the DMS RocketMQ instance.
     */
    name: string;
    /**
     * Indicates the metadata address.
     */
    namesrvAddress: string;
    /**
     * Indicates whether billing based on new specifications is enabled.
     */
    newSpecBillingEnable: boolean;
    /**
     * Indicates the node quantity.
     */
    nodeNum: number;
    /**
     * Indicates the public network service data address.
     */
    publicBrokerAddress: string;
    /**
     * Indicates the public network metadata address.
     */
    publicNamesrvAddress: string;
    /**
     * Indicates the public IP address.
     */
    publicipAddress: string;
    /**
     * Indicates the ID of the EIP bound to the instance.
     */
    publicipId: string;
    /**
     * Indicates the resource specifications.
     */
    resourceSpecCode: string;
    /**
     * Indicates the ID of a security group.
     */
    securityGroupId: string;
    /**
     * Indicates the instance specification.
     */
    specification: string;
    /**
     * Indicates whether the RocketMQ SASL_SSL is enabled.
     */
    sslEnable: boolean;
    /**
     * Indicates the status of the DMS RocketMQ instance.
     */
    status: string;
    /**
     * Indicates the message storage capacity. Unit: GB.
     */
    storageSpace: number;
    /**
     * Indicates the storage I/O specification.
     */
    storageSpecCode: string;
    /**
     * Indicates the ID of a subnet.
     */
    subnetId: string;
    /**
     * Indicates the DMS RocketMQ instance type. Value: cluster.
     */
    type: string;
    /**
     * Indicates the used message storage space. Unit: GB.
     */
    usedStorageSpace: number;
    /**
     * Indicates the ID of a VPC.
     */
    vpcId: string;
}

export interface GetDmsRocketmqInstancesInstanceCrossVpcAccess {
    advertisedIp: string;
    /**
     * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
     */
    lisenterIp: string;
    listenerIp: string;
    port: number;
    portId: string;
}

export interface GetDmsRocketmqMessageTracesTrace {
    /**
     * Specifies the message body length.
     */
    bodyLength: number;
    /**
     * Specifies the IP address of the host that generates the message.
     */
    clientHost: string;
    /**
     * Specifies the consumption status.
     */
    consumeStatus: number;
    /**
     * Specifies the time spent.
     */
    costTime: number;
    /**
     * Specifies whether the response is a transaction check response.
     */
    fromTransactionCheck: boolean;
    /**
     * Specifies the producer group or consumer group.
     */
    groupName: string;
    /**
     * Specifies the message keys.
     */
    keys: string;
    /**
     * Specifies the message ID.
     */
    messageId: string;
    /**
     * Specifies the message type.
     */
    messageType: string;
    /**
     * Specifies the offset message ID.
     */
    offsetMessageId: string;
    /**
     * Specifies the request ID.
     */
    requestId: string;
    /**
     * Specifies the number of retry times.
     */
    retryTimes: number;
    /**
     * Specifies the IP address of the host that stores the message.
     */
    storeHost: string;
    /**
     * Specifies whether the request is successful.
     */
    success: boolean;
    /**
     * Specifies the message tag.
     */
    tags: string;
    /**
     * Specifies the time.
     */
    time: string;
    /**
     * Specifies the topic name.
     */
    topic: string;
    /**
     * Specifies the trace type.
     */
    traceType: string;
    /**
     * Specifies the transaction ID.
     */
    transactionId: string;
    /**
     * Specifies the transaction status.
     */
    transactionState: string;
}

export interface GetDmsRocketmqMessagesMessage {
    /**
     * Indicates the message body.
     */
    body: string;
    /**
     * Indicates the message body checksum.
     */
    bodyCrc: number;
    /**
     * Indicates the IP address of the host that generates the message.
     */
    bornHost: string;
    /**
     * Indicates the message generated time.
     */
    bornTime: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
    /**
     * Indicates the property list.
     */
    propertyLists: outputs.GetDmsRocketmqMessagesMessagePropertyList[];
    /**
     * Indicates the queue ID.
     */
    queueId: number;
    /**
     * Indicates the offset in the queue.
     */
    queueOffset: number;
    /**
     * Indicates the number of retry times.
     */
    reconsumeTimes: number;
    /**
     * Indicates the IP address of the host that stores the message.
     */
    storeHost: string;
    /**
     * Indicates the storage size.
     */
    storeSize: number;
    /**
     * Indicates the message stored time.
     */
    storeTime: string;
}

export interface GetDmsRocketmqMessagesMessagePropertyList {
    /**
     * Indicates the property name.
     */
    name: string;
    /**
     * Indicates the property value.
     */
    value: string;
}

export interface GetDmsRocketmqMigrationTasksTask {
    /**
     * Indicates the ID of a metadata migration task.
     */
    id: string;
    /**
     * Indicates the name of a metadata migration task.
     */
    name: string;
    /**
     * Indicates the start time of a metadata migration task.
     */
    startDate: string;
    /**
     * Indicates the status of a metadata migration task.
     */
    status: string;
    /**
     * Indicates the metadata migration task type.
     */
    type: string;
}

export interface GetDmsRocketmqTopicAccessUsersPolicy {
    /**
     * Indicates the user name.
     */
    accessKey: string;
    /**
     * Indicates whether the user is an administrator.
     */
    admin: boolean;
    /**
     * Indicates the permissions.
     */
    perm: string;
    /**
     * Indicates the IP address whitelist.
     */
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqTopicsTopic {
    brokers: outputs.GetDmsRocketmqTopicsTopicBroker[];
    name: string;
    permission: string;
    totalReadQueueNum: number;
    totalWriteQueueNum: number;
}

export interface GetDmsRocketmqTopicsTopicBroker {
    brokerName: string;
    readQueueNum: number;
    writeQueueNum: number;
}

export interface GetDmsRocketmqUsersUser {
    accessKey: string;
    admin: boolean;
    defaultGroupPerm: string;
    defaultTopicPerm: string;
    groupPerms: outputs.GetDmsRocketmqUsersUserGroupPerm[];
    topicPerms: outputs.GetDmsRocketmqUsersUserTopicPerm[];
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqUsersUserGroupPerm {
    name: string;
    perm: string;
}

export interface GetDmsRocketmqUsersUserTopicPerm {
    name: string;
    perm: string;
}

export interface GetDwsFlavorsFlavor {
    /**
     * The list of availability zones.
     */
    availabilityZones: string[];
    /**
     * The type of datastore.
     */
    datastoreType: string;
    /**
     * The version of datastore.
     */
    datastoreVersion: string;
    /**
     * The typical specification, If the volume specification is elastic.
     */
    elasticVolumeSpecs: outputs.GetDwsFlavorsFlavorElasticVolumeSpec[];
    /**
     * The name of the dws node flavor.
     */
    flavorId: string;
    /**
     * The ram of the dws node flavor in GB.
     */
    memory: number;
    /**
     * The default disk size in GB.
     */
    size: number;
    /**
     * The vcpus of the dws node flavor.
     */
    vcpus: number;
    /**
     * Disk type.
     */
    volumetype: string;
}

export interface GetDwsFlavorsFlavorElasticVolumeSpec {
    /**
     * Maximum disk size.
     */
    maxSize: number;
    /**
     * Minimum disk size.
     */
    minSize: number;
    /**
     * Disk size increment step.
     */
    step: number;
}

export interface GetElbFlavorsFlavor {
    bandwidth: number;
    category: number;
    cps: number;
    flavorSoldOut: boolean;
    httpsCps: number;
    id: string;
    lcu: number;
    maxConnections: number;
    name: string;
    publicBorderGroup: string;
    qps: number;
    shared: boolean;
    type: string;
}

export interface GetElbPoolsPool {
    anyPortEnable: boolean;
    /**
     * Whether to enable delayed logout.
     */
    connectionDrainEnabled: boolean;
    /**
     * The timeout of the delayed logout in seconds.
     */
    connectionDrainTimeout: number;
    createdAt: string;
    /**
     * The description of pool.
     */
    description: string;
    enterpriseProjectId: string;
    /**
     * The health monitor ID of the ELB pool.
     */
    healthmonitorId: string;
    /**
     * The pool ID.
     */
    id: string;
    /**
     * The IP version of pool.
     */
    ipVersion: string;
    /**
     * The method of the ELB pool.
     */
    lbMethod: string;
    /**
     * Listener list. For details, see Data structure of the listener field.
     */
    listeners: outputs.GetElbPoolsPoolListener[];
    /**
     * Loadbalancer list. For details, see Data structure of the loadbalancer field.
     */
    loadbalancers: outputs.GetElbPoolsPoolLoadbalancer[];
    memberDeletionProtectionEnable: boolean;
    /**
     * Loadbalancer list. For details, see Data structure of the members field.
     */
    members: outputs.GetElbPoolsPoolMember[];
    /**
     * The timeout of the delayed logout in seconds.
     */
    minimumHealthyMemberCount: number;
    /**
     * The pool name.
     */
    name: string;
    /**
     * Whether connections in the same session will be processed by the same pool member or not.
     */
    persistences: outputs.GetElbPoolsPoolPersistence[];
    /**
     * The reason for update protection.
     */
    protectionReason: string;
    /**
     * The protection status for update.
     */
    protectionStatus: string;
    /**
     * The protocol of pool.
     */
    protocol: string;
    publicBorderGroup: string;
    quicCidHashStrategies: outputs.GetElbPoolsPoolQuicCidHashStrategy[];
    /**
     * The slow start duration, in seconds.
     */
    slowStartDuration: number;
    /**
     * Whether to enable slow start.
     */
    slowStartEnabled: boolean;
    /**
     * The type of the backend server group.
     */
    type: string;
    updatedAt: string;
    /**
     * The ID of the VPC where the backend server group works.
     */
    vpcId: string;
}

export interface GetElbPoolsPoolListener {
    /**
     * The listener ID.
     */
    id: string;
}

export interface GetElbPoolsPoolLoadbalancer {
    /**
     * The loadbalancer ID.
     */
    id: string;
}

export interface GetElbPoolsPoolMember {
    /**
     * The member ID.
     */
    id: string;
}

export interface GetElbPoolsPoolPersistence {
    /**
     * The name of the cookie if persistence mode is set appropriately.
     */
    cookieName: string;
    /**
     * The stickiness duration, in minutes.
     */
    timeout: number;
    /**
     * The type of persistence mode.
     */
    type: string;
}

export interface GetElbPoolsPoolQuicCidHashStrategy {
    len: number;
    offset: number;
}

export interface GetErAssociationsAssociation {
    attachmentId: string;
    attachmentType: string;
    createdAt: string;
    id: string;
    resourceId: string;
    routePolicyId: string;
    routeTableId: string;
    status: string;
    updatedAt: string;
}

export interface GetErAttachmentsAttachment {
    /**
     * Whether this attachment has been associated.
     */
    associated: boolean;
    /**
     * The creation time of the attachment.
     */
    createdAt: string;
    /**
     * The description of the attachment.
     */
    description: string;
    /**
     * The attachment ID.
     */
    id: string;
    /**
     * The attachment name.
     */
    name: string;
    /**
     * The associated resource ID.
     */
    resourceId: string;
    /**
     * The associated route table ID.
     */
    routeTableId: string;
    /**
     * The current status of the attachment.
     */
    status: string;
    /**
     * The key/value pairs to associate with the attachment.
     */
    tags: {[key: string]: string};
    /**
     * The attachment type.
     */
    type: string;
    /**
     * The latest update time of the attachment.
     */
    updatedAt: string;
}

export interface GetErAvailableRoutesRoute {
    /**
     * The destination address of the route.
     */
    destination: string;
    /**
     * The route ID.
     */
    id: string;
    /**
     * Whether the route is a blackhole route.
     */
    isBlackhole: boolean;
    /**
     * The next hops of the route.
     */
    nextHops: outputs.GetErAvailableRoutesRouteNextHop[];
    /**
     * The route type.
     */
    type: string;
}

export interface GetErAvailableRoutesRouteNextHop {
    /**
     * The attachment ID.
     */
    attachmentId: string;
    /**
     * The attached resource ID.
     */
    resourceId: string;
    /**
     * The attachment type.
     */
    resourceType: string;
}

export interface GetErFlowLogsFlowLog {
    /**
     * The creation time of the flow log.
     */
    createdAt: string;
    /**
     * The description of the flow log.
     */
    description: string;
    /**
     * The switch of the flow log.
     */
    enabled: boolean;
    /**
     * The ID of the flow log.
     */
    id: string;
    /**
     * The ID of the log group to which the flow log belongs.
     */
    logGroupId: string;
    /**
     * The storage type of the flow log.
     */
    logStoreType: string;
    /**
     * The ID of the log stream to which the flow log belongs.
     */
    logStreamId: string;
    /**
     * The name of the flow log.
     */
    name: string;
    /**
     * The ID of the attachment to which the flow log belongs.
     */
    resourceId: string;
    /**
     * The type of the flow log.
     */
    resourceType: string;
    /**
     * The status of the flow log.
     */
    status: string;
    /**
     * The latest update time of the flow log.
     */
    updatedAt: string;
}

export interface GetErInstancesInstance {
    /**
     * The BGP AS number of the ER instance.
     */
    asn: number;
    /**
     * Whether to automatically accept the creation of shared attachment.
     */
    autoAcceptSharedAttachments: boolean;
    /**
     * The availability zone list where the ER instance is located.
     */
    availabilityZones: string[];
    /**
     * The creation time of the instance.
     */
    createdAt: string;
    /**
     * The ID of the default association route table.
     */
    defaultAssociationRouteTableId: string;
    /**
     * The ID of the default propagation route table.
     */
    defaultPropagationRouteTableId: string;
    /**
     * The description of the instance.
     */
    description: string;
    /**
     * Whether to enable the association of the default route table.
     */
    enableDefaultAssociation: boolean;
    /**
     * Whether to enable the propagation of the default route table.
     */
    enableDefaultPropagation: boolean;
    /**
     * The ID of enterprise project to which the instance belongs.
     */
    enterpriseProjectId: string;
    /**
     * The instance ID.
     */
    id: string;
    /**
     * The name of the instance.
     */
    name: string;
    /**
     * The current status of the instance.
     */
    status: string;
    /**
     * The key/value pairs to associate with the instance.
     */
    tags: {[key: string]: string};
    /**
     * The last update time of the instance.
     */
    updatedAt: string;
}

export interface GetErPropagationsPropagation {
    attachmentId: string;
    attachmentType: string;
    createdAt: string;
    id: string;
    instanceId: string;
    resourceId: string;
    routePolicyId: string;
    routeTableId: string;
    status: string;
    updatedAt: string;
}

export interface GetErQuotasQuota {
    /**
     * The number of available quotas, `-1` means unlimited.
     */
    limit: number;
    /**
     * The quota type.
     */
    type: string;
    /**
     * The unit of usage.
     */
    unit: string;
    /**
     * The number of quota used.
     */
    used: number;
}

export interface GetErRouteTablesRouteTable {
    /**
     * The association configuration of the route table.
     */
    associations: outputs.GetErRouteTablesRouteTableAssociation[];
    /**
     * The creation time.
     */
    createdAt: string;
    /**
     * The description of the route table.
     */
    description: string;
    /**
     * The route table ID.
     */
    id: string;
    /**
     * Whether this route table is the default association route table.
     */
    isDefaultAssociation: boolean;
    /**
     * Whether this route table is the default propagation route table.
     */
    isDefaultPropagation: boolean;
    /**
     * The name of the route table.
     */
    name: string;
    /**
     * The propagation configuration of the route table.
     */
    propagations: outputs.GetErRouteTablesRouteTablePropagation[];
    /**
     * The route details of the route table.
     */
    routes: outputs.GetErRouteTablesRouteTableRoute[];
    /**
     * The current status of the route table.
     */
    status: string;
    /**
     * The tags configuration of the route table.
     */
    tags: {[key: string]: string};
    /**
     * The latest update time.
     */
    updatedAt: string;
}

export interface GetErRouteTablesRouteTableAssociation {
    /**
     * The attachment ID corresponding to the routing association/propagation.
     */
    attachmentId: string;
    /**
     * The attachment type corresponding to the routing association/propagation.
     */
    attachmentType: string;
    /**
     * The ID of the association/propagation.
     */
    id: string;
}

export interface GetErRouteTablesRouteTablePropagation {
    /**
     * The attachment ID corresponding to the routing association/propagation.
     */
    attachmentId: string;
    /**
     * The attachment type corresponding to the routing association/propagation.
     */
    attachmentType: string;
    /**
     * The ID of the association/propagation.
     */
    id: string;
}

export interface GetErRouteTablesRouteTableRoute {
    /**
     * The details of the attachment corresponding to the route.
     */
    attachments: outputs.GetErRouteTablesRouteTableRouteAttachment[];
    /**
     * The destination address (CIDR) of the route.
     */
    destination: string;
    /**
     * The route ID.
     */
    id: string;
    /**
     * Whether route is the black hole route.
     */
    isBlackhole: boolean;
    /**
     * The current status of the route.
     */
    status: string;
}

export interface GetErRouteTablesRouteTableRouteAttachment {
    /**
     * The ID of the nexthop attachment.
     */
    attachmentId: string;
    /**
     * The type of the nexthop attachment.
     */
    attachmentType: string;
    /**
     * The ID of the resource associated with the attachment.
     */
    resourceId: string;
}

export interface GetErTagsTag {
    /**
     * The key of the resource tag.
     */
    key: string;
    /**
     * All values corresponding to the key.
     */
    values: string[];
}

export interface GetEvsVolumesVolume {
    attachments: outputs.GetEvsVolumesVolumeAttachment[];
    availabilityZone: string;
    bootable: boolean;
    createAt: string;
    dedicatedStorageId: string;
    dedicatedStorageName: string;
    description: string;
    enterpriseProjectId: string;
    id: string;
    iops: number;
    iopsAttributes: outputs.GetEvsVolumesVolumeIopsAttribute[];
    links: outputs.GetEvsVolumesVolumeLink[];
    metadata: {[key: string]: string};
    name: string;
    serialNumber: string;
    serviceType: string;
    shareable: boolean;
    size: number;
    snapshotId: string;
    status: string;
    tags: {[key: string]: string};
    throughput: number;
    throughputAttributes: outputs.GetEvsVolumesVolumeThroughputAttribute[];
    updateAt: string;
    volumeImageMetadata: {[key: string]: string};
    volumeType: string;
    wwn: string;
}

export interface GetEvsVolumesVolumeAttachment {
    attachedAt: string;
    attachedMode: string;
    attachedVolumeId: string;
    deviceName: string;
    hostName: string;
    id: string;
    serverId: string;
    volumeId: string;
}

export interface GetEvsVolumesVolumeIopsAttribute {
    frozened: boolean;
    id: string;
    totalVal: number;
}

export interface GetEvsVolumesVolumeLink {
    href: string;
    rel: string;
}

export interface GetEvsVolumesVolumeThroughputAttribute {
    frozened: boolean;
    id: string;
    totalVal: number;
}

export interface GetFgsApplicationTemplatesTemplate {
    /**
     * The template category.
     */
    category: string;
    /**
     * The description of template.
     */
    description: string;
    /**
     * The template ID.
     */
    id: string;
    /**
     * The template name.
     */
    name: string;
    /**
     * The template runtime.
     */
    runtime: string;
    /**
     * The type of the function application.
     */
    type: string;
}

export interface GetFgsApplicationsApplication {
    /**
     * The latest update time of the application, in RFC3339 format.
     */
    description: string;
    /**
     * The ID of application.
     */
    id: string;
    /**
     * The name of application.
     */
    name: string;
    /**
     * The status of application.
     */
    status: string;
    /**
     * The description of application.
     */
    updatedAt: string;
}

export interface GetFgsDependenciesPackage {
    /**
     * The unique ID of the dependency package.
     */
    etag: string;
    /**
     * The file name of the stored dependency package.
     */
    fileName: string;
    /**
     * The ID of the dependency package.
     */
    id: string;
    /**
     * The OBS bucket path where the dependency package is located (FunctionGraph serivce side).
     */
    link: string;
    /**
     * The name of the dependency package.
     */
    name: string;
    /**
     * The owner of the dependency package.
     */
    owner: string;
    /**
     * The runtime of the dependency package.
     */
    runtime: string;
    /**
     * The size of the dependency package.
     */
    size: number;
    /**
     * The list of the versions for the dependency package.
     */
    versions: outputs.GetFgsDependenciesPackageVersion[];
}

export interface GetFgsDependenciesPackageVersion {
    /**
     * The ID of the dependency package version.
     */
    id: string;
    /**
     * The dependency package version.
     */
    version: number;
}

export interface GetFgsDependencyVersionsVersion {
    /**
     * The ID of the dependency package corresponding to the version.
     */
    dependencyId: string;
    /**
     * The name of the dependency package corresponding to the version.
     */
    dependencyName: string;
    /**
     * The description of the dependency package version.
     */
    description: string;
    /**
     * The unique ID of the dependency.
     */
    etag: string;
    /**
     * The ID of the dependency package version.
     */
    id: string;
    /**
     * The OBS bucket path where the dependency package version is located.
     */
    link: string;
    /**
     * The dependency owner, public indicates a public dependency.
     */
    owner: string;
    /**
     * The runtime of the dependency package version.
     */
    runtime: string;
    /**
     * The size of the ZIP file used by the dependency package version, in bytes.
     */
    size: number;
    /**
     * The dependency package version.
     */
    version: number;
}

export interface GetFgsFunctionEventsEvent {
    /**
     * The event ID.
     */
    id: string;
    /**
     * The event name.
     */
    name: string;
    /**
     * The latest update time of the function event, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetFgsFunctionTriggersTrigger {
    /**
     * The creation time of the function trigger, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The detailed configuration of the function trigger.
     */
    eventData: string;
    /**
     * The ID of the function trigger.
     */
    id: string;
    /**
     * The current status of the function trigger.
     */
    status: string;
    /**
     * The type of the function trigger.
     */
    type: string;
    /**
     * The latest update time of the function trigger, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetFgsFunctionsFunction {
    /**
     * The IAM agency name for the function configuration.
     */
    agency: string;
    /**
     * The IAM agency name for the function execution.
     */
    appAgency: string;
    /**
     * The name of the function file.
     */
    codeFilename: string;
    /**
     * The function code type.
     */
    codeType: string;
    /**
     * The code URL.
     */
    codeUrl: string;
    /**
     * The description of the function.
     */
    description: string;
    /**
     * The custom user data (key/value pairs) defined to be encrypted for the function.
     */
    encryptedUserData: string;
    /**
     * The enterprise project ID to which the function belongs.
     */
    enterpriseProjectId: string;
    /**
     * The functionGraph version.
     */
    functiongraphVersion: string;
    /**
     * The entry point of the function.
     */
    handler: string;
    /**
     * The initializer of the function.
     */
    initializerHandler: string;
    /**
     * The maximum duration the function can be initialized.
     */
    initializerTimeout: number;
    /**
     * The LTS log group ID.
     */
    logGroupId: string;
    /**
     * The LTS log stream ID.
     */
    logStreamId: string;
    /**
     * The maximum number of instances for a single function.
     */
    maxInstanceNum: string;
    /**
     * The memory size(MB) allocated to the function.
     */
    memorySize: number;
    /**
     * The function name.
     */
    name: string;
    /**
     * The network ID of subnet to which the function belongs.
     */
    networkId: string;
    /**
     * The package name that function used.
     */
    package: string;
    /**
     * The dependency package runtime of the function.
     */
    runtime: string;
    /**
     * The timeout interval of the function.
     */
    timeout: number;
    /**
     * The function URN.
     */
    urn: string;
    /**
     * The custom user data (key/value pairs) defined for the function.
     */
    userData: string;
    /**
     * The function version.
     */
    version: string;
    /**
     * The VPC ID to which the function belongs.
     */
    vpcId: string;
}

export interface GetFgsQuotasQuota {
    /**
     * The number of available quota.
     */
    limit: number;
    /**
     * The resource type corresponding to quota.
     */
    type: string;
    /**
     * The unit of usage.
     */
    unit: string;
    /**
     * The number of quota used.
     */
    used: number;
}

export interface GetIdentityGroupUser {
    description: string;
    enabled: boolean;
    id: string;
    name: string;
    passwordExpiresAt: string;
    passwordStatus: boolean;
    passwordStrength: string;
}

export interface GetIdentityProjectsProject {
    enabled: boolean;
    id: string;
    name: string;
}

export interface GetIdentityUsersUser {
    description: string;
    enabled: boolean;
    groups: string[];
    id: string;
    name: string;
    passwordExpiresAt: string;
    passwordStatus: boolean;
}

export interface GetImagesImagesImage {
    __supportAgentList: string;
    activeAt: string;
    architecture: string;
    backupId: string;
    containerFormat: string;
    createdAt: string;
    dataOrigin: string;
    description: string;
    diskFormat: string;
    enterpriseProjectId: string;
    file: string;
    id: string;
    imageType: string;
    maxRamMb: number;
    minDiskGb: number;
    minRamMb: number;
    name: string;
    os: string;
    osVersion: string;
    owner: string;
    protected: boolean;
    schema: string;
    sizeBytes: number;
    status: string;
    updatedAt: string;
    visibility: string;
}

export interface GetKpsFailedTasksTask {
    /**
     * The ID of the task.
     */
    id: string;
    /**
     * The name of the keypair associated with the task.
     */
    keypairName: string;
    /**
     * The operation type of the task.
     */
    operateType: string;
    /**
     * The ID of the instance associated with the task.
     */
    serverId: string;
    /**
     * The name of the instance associated with the task.
     */
    serverName: string;
    /**
     * The error code of the task execution failure.
     */
    taskErrorCode: string;
    /**
     * The error information of the task execution failure.
     */
    taskErrorMsg: string;
    /**
     * The start time of the task, in RFC3339 format.
     */
    taskTime: string;
}

export interface GetKpsKeypairsKeypair {
    fingerprint: string;
    isManaged: boolean;
    name: string;
    publicKey: string;
    scope: string;
}

export interface GetKpsRunningTasksTask {
    /**
     * The ID of the task.
     */
    id: string;
    /**
     * The name of the keypair associated with the task.
     */
    keypairName: string;
    /**
     * The operation type of the task.
     */
    operateType: string;
    /**
     * The ID of the instance associated with the task.
     */
    serverId: string;
    /**
     * The name of the instance associated with the task.
     */
    serverName: string;
    /**
     * The start time of the task, in RFC3339 format.
     */
    taskTime: string;
}

export interface GetLbListenersListener {
    clientCaTlsContainerRef: string;
    connectionLimit: number;
    createdAt: string;
    defaultPoolId: string;
    defaultTlsContainerRef: string;
    description: string;
    http2Enable: boolean;
    id: string;
    insertHeaders: outputs.GetLbListenersListenerInsertHeader[];
    loadbalancers: outputs.GetLbListenersListenerLoadbalancer[];
    name: string;
    protectionReason: string;
    protectionStatus: string;
    protocol: string;
    protocolPort: number;
    sniContainerRefs: string[];
    tags: {[key: string]: string};
    tlsCiphersPolicy: string;
    updatedAt: string;
}

export interface GetLbListenersListenerInsertHeader {
    xForwardedElbIp: string;
    xForwardedHost: string;
}

export interface GetLbListenersListenerLoadbalancer {
    /**
     * The loadbalancer ID.
     */
    id: string;
}

export interface GetLbPoolsPool {
    description: string;
    healthmonitorId: string;
    id: string;
    lbMethod: string;
    listeners: outputs.GetLbPoolsPoolListener[];
    loadbalancers: outputs.GetLbPoolsPoolLoadbalancer[];
    members: outputs.GetLbPoolsPoolMember[];
    name: string;
    persistences: outputs.GetLbPoolsPoolPersistence[];
    protectionReason: string;
    protectionStatus: string;
    protocol: string;
}

export interface GetLbPoolsPoolListener {
    id: string;
}

export interface GetLbPoolsPoolLoadbalancer {
    id: string;
}

export interface GetLbPoolsPoolMember {
    id: string;
}

export interface GetLbPoolsPoolPersistence {
    cookieName: string;
    timeout: number;
    type: string;
}

export interface GetNetworkingSecgroupRule {
    action: string;
    description: string;
    direction: string;
    ethertype: string;
    id: string;
    /**
     * schema: Deprecated
     */
    portRangeMax: number;
    /**
     * schema: Deprecated
     */
    portRangeMin: number;
    ports: string;
    priority: number;
    protocol: string;
    remoteAddressGroupId: string;
    remoteGroupId: string;
    remoteIpPrefix: string;
}

export interface GetNetworkingSecgroupsSecurityGroup {
    createdAt: string;
    description: string;
    enterpriseProjectId: string;
    id: string;
    name: string;
    updatedAt: string;
}

export interface GetObsBucketsBucket {
    bucket: string;
    createdAt: string;
    enterpriseProjectId: string;
    region: string;
    storageClass: string;
}

export interface GetRdsBackupsBackup {
    /**
     * Whether a DDM instance has been associated.
     */
    associatedWithDdm: boolean;
    /**
     * Backup start time in the "yyyy-mm-ddThh:mm:ssZ" format.
     */
    beginTime: string;
    /**
     * Database been backed up.
     */
    databases: outputs.GetRdsBackupsBackupDatabase[];
    datastores: outputs.GetRdsBackupsBackupDatastore[];
    /**
     * Backup end time in the "yyyy-mm-ddThh:mm:ssZ" format.
     */
    endTime: string;
    /**
     * Backup ID.
     */
    id: string;
    /**
     * RDS instance ID.
     */
    instanceId: string;
    /**
     * Backup name.
     */
    name: string;
    /**
     * Backup size in KB.
     */
    size: number;
    /**
     * Backup status.
     */
    status: string;
    /**
     * Backup type.
     */
    type: string;
}

export interface GetRdsBackupsBackupDatabase {
    /**
     * Database to be backed up for Microsoft SQL Server.
     */
    name: string;
}

export interface GetRdsBackupsBackupDatastore {
    /**
     * DB engine.
     */
    type: string;
    /**
     * DB engine version.
     */
    version: string;
}

export interface GetRdsEngineVersionsVersion {
    id: string;
    name: string;
}

export interface GetRdsFlavorsFlavor {
    availabilityZones: string[];
    dbVersions: string[];
    groupType: string;
    id: string;
    instanceMode: string;
    memory: number;
    /**
     * @deprecated use instanceMode instead
     */
    mode: string;
    name: string;
    vcpus: number;
}

export interface GetRdsInstancesInstance {
    availabilityZones: string[];
    backupStrategies: outputs.GetRdsInstancesInstanceBackupStrategy[];
    created: string;
    dbs: outputs.GetRdsInstancesInstanceDb[];
    enterpriseProjectId: string;
    fixedIp: string;
    flavor: string;
    haReplicationMode: string;
    id: string;
    name: string;
    nodes: outputs.GetRdsInstancesInstanceNode[];
    paramGroupId: string;
    privateIps: string[];
    publicIps: string[];
    region: string;
    securityGroupId: string;
    sslEnable: boolean;
    status: string;
    subnetId: string;
    tags: {[key: string]: string};
    timeZone: string;
    volumes: outputs.GetRdsInstancesInstanceVolume[];
    vpcId: string;
}

export interface GetRdsInstancesInstanceBackupStrategy {
    keepDays: number;
    startTime: string;
}

export interface GetRdsInstancesInstanceDb {
    port: number;
    type: string;
    userName: string;
    version: string;
}

export interface GetRdsInstancesInstanceNode {
    availabilityZone: string;
    id: string;
    name: string;
    role: string;
    status: string;
}

export interface GetRdsInstancesInstanceVolume {
    diskEncryptionId: string;
    size: number;
    type: string;
}

export interface GetRdsPgAccountsUser {
    attributes: outputs.GetRdsPgAccountsUserAttribute[];
    description: string;
    memberofs: string[];
    name: string;
}

export interface GetRdsPgAccountsUserAttribute {
    rolbypassrls: boolean;
    rolcanlogin: boolean;
    rolconnlimit: number;
    rolcreatedb: boolean;
    rolcreaterole: boolean;
    rolinherit: boolean;
    rolreplication: boolean;
    rolsuper: boolean;
}

export interface GetRdsPgDatabasesDatabase {
    characterSet: string;
    description: string;
    lcCollate: string;
    name: string;
    owner: string;
    size: number;
}

export interface GetRdsPgPluginsPlugin {
    /**
     * Indicates whether the plugin has been created.
     */
    created: boolean;
    /**
     * Indicates the plugin description.
     */
    description: string;
    /**
     * Indicates the plugin name.
     */
    name: string;
    /**
     * Indicates the dependent preloaded library.
     */
    sharedPreloadLibraries: string;
    /**
     * Indicates the plugin version.
     */
    version: string;
}

export interface GetRdsPgSqlLimitsSqlLimit {
    /**
     * Indicates the ID of SQL limit.
     */
    id: string;
    /**
     * Indicates whether the SQL limit is effective.
     */
    isEffective: boolean;
    /**
     * Indicates the number of SQL statements executed simultaneously.
     */
    maxConcurrency: number;
    /**
     * Indicates the max waiting time in seconds.
     */
    maxWaiting: number;
    /**
     * Indicates the query ID.
     */
    queryId: string;
    /**
     * Indicates the text form of SQL statement.
     */
    queryString: string;
    /**
     * Indicates the query order for names that are not schema qualified.
     */
    searchPath: string;
}

export interface GetRdsStorageTypesStorageType {
    /**
     * The status details of the AZs to which the specification belongs.
     */
    azStatus: {[key: string]: string};
    /**
     * Storage type.
     */
    name: string;
    /**
     * Performance specifications.
     */
    supportComputeGroupTypes: string[];
}

export interface GetSfsTurboDataTasksTask {
    /**
     * The destination path prefix of the data task.
     */
    destPrefix: string;
    /**
     * The target end information of the data task.
     */
    destTarget: string;
    /**
     * The end time of the data task, in RFC3339 format.
     */
    endTime: string;
    /**
     * The ID of the data task.
     */
    id: string;
    /**
     * The data task execution result information.
     */
    message: string;
    /**
     * The source path prefix of the data task.
     */
    srcPrefix: string;
    /**
     * The linkage directory name.
     */
    srcTarget: string;
    /**
     * The start time of the data task, in RFC3339 format.
     */
    startTime: string;
    /**
     * The status of the data task.
     */
    status: string;
    /**
     * The type of the data task.
     */
    type: string;
}

export interface GetSfsTurboDuTasksTask {
    /**
     * The start time of the DU task, in RFC3339 format.
     */
    beginTime: string;
    /**
     * The resource usages of a directory (including subdirectories).
     */
    dirUsages: outputs.GetSfsTurboDuTasksTaskDirUsage[];
    /**
     * The end time of the DU task, in RFC3339 format.
     */
    endTime: string;
    /**
     * The ID of the DU task.
     */
    id: string;
    /**
     * The status of the DU task.
     */
    status: string;
}

export interface GetSfsTurboDuTasksTaskDirUsage {
    /**
     * The total number of files in the directory.
     */
    fileCounts: outputs.GetSfsTurboDuTasksTaskDirUsageFileCount[];
    /**
     * The error message.
     */
    message: string;
    /**
     * The full path to a legal directory in the file system.
     */
    path: string;
    /**
     * The used capacity, in byte.
     */
    usedCapacity: number;
}

export interface GetSfsTurboDuTasksTaskDirUsageFileCount {
    /**
     * The number of block devices.
     */
    block: number;
    /**
     * The number of character devices.
     */
    char: number;
    /**
     * The number of directories.
     */
    dir: number;
    /**
     * The number of pipe files.
     */
    pipe: number;
    /**
     * The number of common files.
     */
    regular: number;
    /**
     * The number of sockets.
     */
    socket: number;
    /**
     * The number of symbolic links.
     */
    symlink: number;
}

export interface GetSfsTurboObsTargetsTarget {
    /**
     * The creation time of the OBS target.
     */
    createdAt: string;
    /**
     * The linkage directory name of the OBS target.
     */
    fileSystemPath: string;
    /**
     * The ID of the OBS target.
     */
    id: string;
    /**
     * The detail of the OBS bucket.
     */
    obs: outputs.GetSfsTurboObsTargetsTargetOb[];
    /**
     * The status of the OBS target.
     */
    status: string;
}

export interface GetSfsTurboObsTargetsTargetOb {
    /**
     * The name of the OBS bucket associated with the OBS target.
     */
    bucket: string;
    /**
     * The domain name of the region where the OBS bucket belongs.
     */
    endpoint: string;
}

export interface GetSfsTurboPermRulesRule {
    /**
     * The ID of the permission rule.
     */
    id: string;
    /**
     * The IP address or IP address range of the authorized object.
     */
    ipCidr: string;
    /**
     * The read and write permission of the authorized object.
     */
    rwType: string;
    /**
     * The file system access permission granted to the user of the authorized object.
     */
    userType: string;
}

export interface GetSfsTurbosTurbo {
    availabilityZone: string;
    availableCapacity: string;
    cryptKeyId: string;
    enhanced: boolean;
    enterpriseProjectId: string;
    exportLocation: string;
    id: string;
    name: string;
    securityGroupId: string;
    shareProto: string;
    shareType: string;
    size: number;
    subnetId: string;
    version: string;
    vpcId: string;
}

export interface GetVpcAddressGroupsAddressGroup {
    /**
     * IP address sets in an IP address group.
     */
    addresses: string[];
    /**
     * Time when the IP address group is created.
     */
    createdAt: string;
    /**
     * The supplementary information about the IP address group.
     */
    description: string;
    /**
     * Enterprise project ID.
     */
    enterpriseProjectId: string;
    /**
     * IP address group ID, which uniquely identifies the IP address group.
     */
    id: string;
    /**
     * IP addresses and their remarks in an IP address group.
     */
    ipExtraSets: outputs.GetVpcAddressGroupsAddressGroupIpExtraSet[];
    /**
     * Whether it is an IPv4 or IPv6 address group.
     */
    ipVersion: number;
    /**
     * Maximum number of entries in an address group,
     */
    maxCapacity: number;
    /**
     * IP address group name.
     */
    name: string;
    /**
     * The status of IP address group.
     */
    status: string;
    /**
     * The status details of IP address group.
     */
    statusMessage: string;
    /**
     * Time when the IP address group was last updated.
     */
    updatedAt: string;
}

export interface GetVpcAddressGroupsAddressGroupIpExtraSet {
    /**
     * An IP address, IP address range, or CIDR block.
     */
    ip: string;
    /**
     * Provides supplementary information about the IP address, IP address range, or CIDR block.
     */
    remarks: string;
}

export interface GetVpcBandwidthPublicip {
    id: string;
    ipAddress: string;
    ipVersion: number;
    type: string;
}

export interface GetVpcEipsEip {
    bandwidthId: string;
    bandwidthName: string;
    bandwidthShareType: string;
    bandwidthSize: number;
    createdAt: string;
    enterpriseProjectId: string;
    id: string;
    ipVersion: number;
    name: string;
    portId: string;
    privateIp: string;
    publicIp: string;
    publicIpv6: string;
    status: string;
    tags: {[key: string]: string};
    type: string;
}

export interface GetVpcRoute {
    destination: string;
    nexthop: string;
}

export interface GetVpcRouteTableRoute {
    description: string;
    destination: string;
    nexthop: string;
    type: string;
}

export interface GetVpcRoutesRoute {
    /**
     * The route destination.
     */
    destination: string;
    /**
     * The route ID.
     */
    id: string;
    /**
     * The next hop of the route.
     */
    nexthop: string;
    /**
     * The route type.
     */
    type: string;
    /**
     * The ID of the VPC to which the route belongs.
     */
    vpcId: string;
}

export interface GetVpcSubnetsSubnet {
    availabilityZone: string;
    cidr: string;
    description: string;
    dhcpEnable: boolean;
    dnsLists: string[];
    gatewayIp: string;
    id: string;
    ipv4SubnetId: string;
    ipv6Cidr: string;
    ipv6Enable: boolean;
    ipv6Gateway: string;
    ipv6SubnetId: string;
    name: string;
    primaryDns: string;
    secondaryDns: string;
    status: string;
    /**
     * schema: Deprecated
     */
    subnetId: string;
    tags: {[key: string]: string};
    vpcId: string;
}

export interface GetVpcepPublicServicesService {
    id: string;
    isCharge: boolean;
    owner: string;
    serviceName: string;
    serviceType: string;
}

export interface GetVpcsVpc {
    cidr: string;
    description: string;
    enterpriseProjectId: string;
    id: string;
    name: string;
    secondaryCidrs: string[];
    status: string;
    tags: {[key: string]: string};
}

export interface GetVpnConnectionHealthChecksConnectionHealthCheck {
    connectionId: string;
    destinationIp: string;
    id: string;
    protoType: string;
    sourceIp: string;
    status: string;
    type: string;
}

export interface GetVpnConnectionsConnection {
    connectionMonitorId: string;
    createdAt: string;
    customerGatewayId: string;
    enableNqa: boolean;
    enterpriseProjectId: string;
    gatewayId: string;
    gatewayIp: string;
    haRole: string;
    id: string;
    ikepolicies: outputs.GetVpnConnectionsConnectionIkepolicy[];
    ipsecpolicies: outputs.GetVpnConnectionsConnectionIpsecpolicy[];
    name: string;
    peerSubnets: string[];
    policyRules: outputs.GetVpnConnectionsConnectionPolicyRule[];
    status: string;
    tunnelLocalAddress: string;
    tunnelPeerAddress: string;
    updatedAt: string;
    vpnType: string;
}

export interface GetVpnConnectionsConnectionIkepolicy {
    authenticationAlgorithm: string;
    authenticationMethod: string;
    dhGroup: string;
    dpds: outputs.GetVpnConnectionsConnectionIkepolicyDpd[];
    encryptionAlgorithm: string;
    ikeVersion: string;
    lifetimeSeconds: number;
    localId: string;
    localIdType: string;
    peerId: string;
    peerIdType: string;
    phase1NegotiationMode: string;
}

export interface GetVpnConnectionsConnectionIkepolicyDpd {
    interval: number;
    msg: string;
    timeout: number;
}

export interface GetVpnConnectionsConnectionIpsecpolicy {
    authenticationAlgorithm: string;
    encapsulationMode: string;
    encryptionAlgorithm: string;
    lifetimeSeconds: number;
    pfs: string;
    transformProtocol: string;
}

export interface GetVpnConnectionsConnectionPolicyRule {
    destinations: string[];
    ruleIndex: number;
    source: string;
}

export interface GetVpnCustomerGatewaysCustomerGateway {
    asn: number;
    caCertificates: outputs.GetVpnCustomerGatewaysCustomerGatewayCaCertificate[];
    createdAt: string;
    id: string;
    idType: string;
    idValue: string;
    ip: string;
    name: string;
    routeMode: string;
    updatedAt: string;
}

export interface GetVpnCustomerGatewaysCustomerGatewayCaCertificate {
    expireTime: string;
    isUpdatable: boolean;
    issuer: string;
    serialNumber: string;
    signatureAlgorithm: string;
    subject: string;
}

export interface GetVpnGatewaysGateway {
    /**
     * The list of private access IPs.
     */
    accessPrivateIps: string[];
    /**
     * The ID of the access subnet.
     */
    accessSubnetId: string;
    /**
     * The ID of the access VPC.
     */
    accessVpcId: string;
    /**
     * The attachment type.
     */
    attachmentType: string;
    /**
     * The availability zone IDs.
     */
    availabilityZones: string[];
    /**
     * The ASN number of BGP
     */
    bgpAsn: number;
    /**
     * The VPC network segment used by the VPN gateway
     */
    connectSubnet: string;
    /**
     * The max number of connections.
     */
    connectionNumber: number;
    /**
     * The create time.
     */
    createdAt: string;
    eips: outputs.GetVpnGatewaysGatewayEip[];
    /**
     * The enterprise project ID
     */
    enterpriseProjectId: string;
    /**
     * The ER attachment ID.
     */
    erAttachmentId: string;
    /**
     * The ID of the ER to which the VPN gateway is connected.
     */
    erId: string;
    /**
     * The flavor of the VPN gateway.
     */
    flavor: string;
    /**
     * The HA mode.
     */
    haMode: string;
    /**
     * The ID of the gateway
     */
    id: string;
    /**
     * The local subnets.
     */
    localSubnets: string[];
    /**
     * The name of the gateway.
     */
    name: string;
    /**
     * The network type of the gateway.
     */
    networkType: string;
    /**
     * The status of the gateway.
     */
    status: string;
    /**
     * The update time.
     */
    updatedAt: string;
    /**
     * The number of used connection groups.
     */
    usedConnectionGroup: number;
    /**
     * The number of used connections.
     */
    usedConnectionNumber: number;
    /**
     * The ID of the VPC to which the VPN gateway is connected.
     */
    vpcId: string;
}

export interface GetVpnGatewaysGatewayEip {
    /**
     * The bandwidth billing info.
     */
    bandwidthBillingInfo: string;
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s.
     */
    bandwidthSize: number;
    /**
     * The billing info.
     */
    billingInfo: string;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export interface IdentityAclIpCidr {
    cidr: string;
    description?: string;
}

export interface IdentityAclIpRange {
    description?: string;
    range: string;
}

export interface IdentityAgencyProjectRole {
    project: string;
    roles: string[];
}

export interface IdentityProviderAccessConfig {
    accessType: string;
    authorizationEndpoint: string;
    clientId: string;
    providerUrl: string;
    responseMode?: string;
    responseType?: string;
    scopes: string[];
    signingKey: string;
}

export interface IdentityProviderConversionConversionRule {
    locals: outputs.IdentityProviderConversionConversionRuleLocal[];
    remotes: outputs.IdentityProviderConversionConversionRuleRemote[];
}

export interface IdentityProviderConversionConversionRuleLocal {
    group?: string;
    username?: string;
}

export interface IdentityProviderConversionConversionRuleRemote {
    attribute: string;
    condition?: string;
    values?: string[];
}

export interface IdentityProviderConversionRule {
    locals: outputs.IdentityProviderConversionRuleLocal[];
    remotes: outputs.IdentityProviderConversionRuleRemote[];
}

export interface IdentityProviderConversionRuleLocal {
    group: string;
    username: string;
}

export interface IdentityProviderConversionRuleRemote {
    attribute: string;
    condition: string;
    values: string[];
}

export interface LbListenerInsertHeaders {
    xForwardedElbIp: string;
    xForwardedHost: string;
}

export interface LbPoolPersistence {
    cookieName?: string;
    timeout: number;
    type: string;
}

export interface MapreduceClusterAnalysisCoreNodes {
    assignedRoles?: string[];
    autoRenew?: string;
    chargingMode: string;
    dataVolumeCount: number;
    dataVolumeSize?: number;
    dataVolumeType?: string;
    flavor: string;
    hostIps: string[];
    nodeNumber: number;
    period?: number;
    periodUnit?: string;
    rootVolumeSize: number;
    rootVolumeType: string;
}

export interface MapreduceClusterAnalysisTaskNodes {
    assignedRoles?: string[];
    dataVolumeCount: number;
    dataVolumeSize?: number;
    dataVolumeType?: string;
    flavor: string;
    hostIps: string[];
    nodeNumber: number;
    rootVolumeSize: number;
    rootVolumeType: string;
}

export interface MapreduceClusterBootstrapScript {
    /**
     * Whether the bootstrap action script runs only on active master nodes.
     */
    activeMaster: boolean;
    /**
     * Whether the bootstrap action script is executed before component start.
     */
    beforeComponentStart: boolean;
    /**
     * Whether the bootstrap action script involves root user operations.
     */
    executeNeedSudoRoot: boolean;
    /**
     * The action after the bootstrap action script fails to be executed.
     */
    failAction: string;
    /**
     * Name of a bootstrap action script.
     */
    name: string;
    /**
     * Name of the node group where the bootstrap action script is executed.
     */
    nodes: string[];
    /**
     * Bootstrap action script parameters.
     */
    parameters?: string;
    /**
     * The execution time of one bootstrap action script, in RFC-3339 format.
     */
    startTime: string;
    /**
     * The status of one bootstrap action script.
     */
    state: string;
    /**
     * Path of a bootstrap action script. Set this parameter to an OBS bucket path or a local VM path.
     */
    uri: string;
}

export interface MapreduceClusterComponentConfig {
    configs: outputs.MapreduceClusterComponentConfigConfig[];
    name: string;
}

export interface MapreduceClusterComponentConfigConfig {
    configFileName: string;
    key: string;
    value: string;
}

export interface MapreduceClusterCustomNode {
    assignedRoles?: string[];
    autoRenew?: string;
    chargingMode: string;
    dataVolumeCount: number;
    dataVolumeSize?: number;
    dataVolumeType?: string;
    flavor: string;
    groupName: string;
    hostIps: string[];
    nodeNumber: number;
    period?: number;
    periodUnit?: string;
    rootVolumeSize: number;
    rootVolumeType: string;
}

export interface MapreduceClusterExternalDatasource {
    componentName: string;
    dataConnectionId?: string;
    roleType: string;
    sourceType: string;
}

export interface MapreduceClusterMasterNodes {
    assignedRoles?: string[];
    autoRenew?: string;
    chargingMode: string;
    dataVolumeCount: number;
    dataVolumeSize?: number;
    dataVolumeType?: string;
    flavor: string;
    hostIps: string[];
    nodeNumber: number;
    period?: number;
    periodUnit?: string;
    rootVolumeSize: number;
    rootVolumeType: string;
}

export interface MapreduceClusterSmnNotify {
    /**
     * The subscription rule name.
     */
    subscriptionName: string;
    /**
     * The Uniform Resource Name (URN) of the topic.
     */
    topicUrn: string;
}

export interface MapreduceClusterStreamingCoreNodes {
    assignedRoles?: string[];
    autoRenew?: string;
    chargingMode: string;
    dataVolumeCount: number;
    dataVolumeSize?: number;
    dataVolumeType?: string;
    flavor: string;
    hostIps: string[];
    nodeNumber: number;
    period?: number;
    periodUnit?: string;
    rootVolumeSize: number;
    rootVolumeType: string;
}

export interface MapreduceClusterStreamingTaskNodes {
    assignedRoles?: string[];
    dataVolumeCount: number;
    dataVolumeSize?: number;
    dataVolumeType?: string;
    flavor: string;
    hostIps: string[];
    nodeNumber: number;
    rootVolumeSize: number;
    rootVolumeType: string;
}

export interface NatGatewaySessionConf {
    /**
     * The ICMP session expiration time.
     */
    icmpSessionExpireTime: number;
    /**
     * The TCP session expiration time.
     */
    tcpSessionExpireTime: number;
    /**
     * The duration of TIME_WAIT state when TCP connection is closed.
     */
    tcpTimeWaitTime: number;
    /**
     * The UDP session expiration time.
     */
    udpSessionExpireTime: number;
}

export interface NetworkingSecgroupRule {
    action: string;
    description: string;
    direction: string;
    ethertype: string;
    id: string;
    /**
     * schema: Deprecated
     */
    portRangeMax: number;
    /**
     * schema: Deprecated
     */
    portRangeMin: number;
    ports: string;
    priority: number;
    protocol: string;
    remoteAddressGroupId: string;
    remoteGroupId: string;
    remoteIpPrefix: string;
}

export interface ObsBucketAclAccountPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
    /**
     * Specifies the account id to authorize. The account id cannot be the bucket owner, 
     * and must be unique.
     */
    accountId: string;
}

export interface ObsBucketAclLogDeliveryUserPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface ObsBucketAclOwnerPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface ObsBucketAclPublicPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface ObsBucketCorsRule {
    allowedHeaders?: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders?: string[];
    maxAgeSeconds?: number;
}

export interface ObsBucketLifecycleRule {
    abortIncompleteMultipartUploads?: outputs.ObsBucketLifecycleRuleAbortIncompleteMultipartUpload[];
    enabled: boolean;
    expirations?: outputs.ObsBucketLifecycleRuleExpiration[];
    name: string;
    noncurrentVersionExpirations?: outputs.ObsBucketLifecycleRuleNoncurrentVersionExpiration[];
    noncurrentVersionTransitions?: outputs.ObsBucketLifecycleRuleNoncurrentVersionTransition[];
    prefix?: string;
    transitions?: outputs.ObsBucketLifecycleRuleTransition[];
}

export interface ObsBucketLifecycleRuleAbortIncompleteMultipartUpload {
    days: number;
}

export interface ObsBucketLifecycleRuleExpiration {
    days: number;
}

export interface ObsBucketLifecycleRuleNoncurrentVersionExpiration {
    days: number;
}

export interface ObsBucketLifecycleRuleNoncurrentVersionTransition {
    days: number;
    storageClass: string;
}

export interface ObsBucketLifecycleRuleTransition {
    days: number;
    storageClass: string;
}

export interface ObsBucketLogging {
    /**
     * schema: Required
     */
    agency: string;
    targetBucket: string;
    targetPrefix?: string;
}

export interface ObsBucketStorageInfo {
    objectNumber: number;
    size: number;
}

export interface ObsBucketWebsite {
    errorDocument?: string;
    indexDocument?: string;
    redirectAllRequestsTo?: string;
    routingRules?: string;
}

export interface RdsBackupDatabase {
    /**
     * Database to be backed up for Microsoft SQL Server.
     */
    name: string;
}

export interface RdsInstanceBackupStrategy {
    /**
     * schema: Required
     */
    keepDays: number;
    period: string;
    startTime: string;
}

export interface RdsInstanceDb {
    password?: string;
    port: number;
    type: string;
    userName: string;
    version: string;
}

export interface RdsInstanceMsdtcHost {
    hostName: string;
    id: string;
    ip: string;
}

export interface RdsInstanceNode {
    availabilityZone: string;
    id: string;
    name: string;
    role: string;
    status: string;
}

export interface RdsInstanceParameter {
    name: string;
    value: string;
}

export interface RdsInstanceRestore {
    backupId: string;
    databaseName?: {[key: string]: string};
    instanceId: string;
}

export interface RdsInstanceVolume {
    diskEncryptionId: string;
    limitSize?: number;
    size: number;
    triggerThreshold?: number;
    type: string;
}

export interface RdsMysqlDatabasePrivilegeUser {
    /**
     * Specifies the username of the database account.
     */
    name: string;
    /**
     * Specifies the read-only permission.
     */
    readonly: boolean;
}

export interface RdsMysqlDatabaseTableRestoreDatabase {
    /**
     * Specifies the name of the database after restoration.
     */
    newName: string;
    /**
     * Specifies the name of the database before restoration.
     */
    oldName: string;
}

export interface RdsMysqlDatabaseTableRestoreRestoreTable {
    /**
     * Specifies the database name.
     */
    database: string;
    /**
     * Specifies the tables.
     */
    tables: outputs.RdsMysqlDatabaseTableRestoreRestoreTableTable[];
}

export interface RdsMysqlDatabaseTableRestoreRestoreTableTable {
    /**
     * Specifies the name of the table after restoration.
     */
    newName: string;
    /**
     * Specifies the name of the table before restoration.
     */
    oldName: string;
}

export interface RdsParametergroupConfigurationParameter {
    description: string;
    name: string;
    readonly: boolean;
    restartRequired: boolean;
    type: string;
    value: string;
    valueRange: string;
}

export interface RdsParametergroupDatastore {
    type: string;
    version: string;
}

export interface RdsPgAccountAttribute {
    /**
     * Indicates whether a user bypasses each row-level security policy.
     */
    rolBypassRls: boolean;
    /**
     * Indicates whether a user can log in to the database.
     */
    rolCanLogin: boolean;
    /**
     * Indicates the maximum number of concurrent connections to a DB instance.
     */
    rolConnLimit: number;
    /**
     * Indicates whether a user can create a database.
     */
    rolCreateDb: boolean;
    /**
     * Indicates whether a user can create other sub-users.
     */
    rolCreateRole: boolean;
    /**
     * Indicates whether a user automatically inherits the permissions of the role to which the
     * user belongs.
     */
    rolInherit: boolean;
    /**
     * Indicates whether the user is a replication role.
     */
    rolReplication: boolean;
    /**
     * Indicates whether a user has the super-user permission.
     */
    rolSuper: boolean;
}

export interface RdsPgHbaHostBasedAuthentication {
    /**
     * Specifies the client IP address.
     */
    address: string;
    /**
     * Specifies the database name.
     */
    database: string;
    /**
     * Specifies the subnet mask.
     */
    mask: string;
    /**
     * Specifies the authentication mode.
     */
    method: string;
    /**
     * Specifies the connection type.
     */
    type: string;
    /**
     * Specifies the Name of a user.
     */
    user: string;
}

export interface RdsReadReplicaInstanceDb {
    port: number;
    type: string;
    userName: string;
    version: string;
}

export interface RdsReadReplicaInstanceParameter {
    name: string;
    value: string;
}

export interface RdsReadReplicaInstanceVolume {
    /**
     * schema: Computed
     */
    diskEncryptionId: string;
    limitSize?: number;
    size: number;
    triggerThreshold?: number;
    type: string;
}

export interface RdsSqlserverDatabasePrivilegeUser {
    /**
     * Specifies the username of the database account.
     */
    name: string;
    /**
     * Specifies the read-only permission.
     */
    readonly: boolean;
}

export interface SfsFileSystemAccessRule {
    accessLevel: string;
    accessRuleId: string;
    accessTo: string;
    accessType: string;
    status: string;
}

export interface SfsTurboDuTaskDirUsage {
    fileCounts: outputs.SfsTurboDuTaskDirUsageFileCount[];
    message: string;
    path: string;
    usedCapacity: number;
}

export interface SfsTurboDuTaskDirUsageFileCount {
    block: number;
    char: number;
    dir: number;
    pipe: number;
    regular: number;
    socket: number;
    symlink: number;
}

export interface SfsTurboObsTargetObs {
    attributes?: outputs.SfsTurboObsTargetObsAttributes;
    bucket: string;
    endpoint: string;
    policy?: outputs.SfsTurboObsTargetObsPolicy;
}

export interface SfsTurboObsTargetObsAttributes {
    dirMode: string;
    fileMode: string;
    gid: number;
    uid: number;
}

export interface SfsTurboObsTargetObsPolicy {
    autoExportPolicy?: outputs.SfsTurboObsTargetObsPolicyAutoExportPolicy;
}

export interface SfsTurboObsTargetObsPolicyAutoExportPolicy {
    events: string[];
    prefix: string;
    suffix: string;
}

export interface SmnSubscriptionExtension {
    clientId?: string;
    clientSecret?: string;
    header?: {[key: string]: string};
    keyword?: string;
    signSecret?: string;
}

export interface SmnSubscriptionFilterPolicy {
    /**
     * The filter policy name. The policy name must be unique.
     */
    name: string;
    /**
     * The string array for exact match.
     */
    stringEquals: string[];
}

export interface SwrOrganizationPermissionsSelfPermission {
    permission: string;
    userId: string;
    userName: string;
}

export interface SwrOrganizationPermissionsUser {
    permission: string;
    userId: string;
    userName: string;
}

export interface VpcAddressGroupIpExtraSet {
    ip: string;
    remarks?: string;
}

export interface VpcBandwidthPublicip {
    id: string;
    ipAddress: string;
    ipVersion: number;
    type: string;
}

export interface VpcEipBandwidth {
    /**
     * Whether the bandwidth is billed by traffic or by bandwidth size.
     */
    chargeMode: string;
    /**
     * The shared bandwidth ID.
     */
    id: string;
    /**
     * The dedicated bandwidth name.
     */
    name: string;
    /**
     * Whether the bandwidth is dedicated or shared.
     */
    shareType: string;
    /**
     * The dedicated bandwidth size.
     */
    size: number;
}

export interface VpcEipPublicip {
    /**
     * The EIP address to be assigned.
     */
    ipAddress: string;
    /**
     * The IP version.
     */
    ipVersion: number;
    /**
     * schema: Deprecated
     */
    portId: string;
    /**
     * The EIP type.
     */
    type?: string;
}

export interface VpcRoute {
    destination: string;
    nexthop: string;
}

export interface VpcRouteTableRoute {
    description?: string;
    destination: string;
    nexthop: string;
    type: string;
}

export interface VpcepServiceConnection {
    description: string;
    domainId: string;
    endpointId: string;
    packetId: number;
    status: string;
}

export interface VpcepServicePortMapping {
    protocol?: string;
    /**
     * schema: Required
     */
    servicePort?: number;
    /**
     * schema: Required
     */
    terminalPort?: number;
}

export interface VpnConnectionIkepolicy {
    /**
     * The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
     */
    authenticationAlgorithm: string;
    /**
     * The authentication method during IKE negotiation.
     */
    authenticationMethod: string;
    /**
     * Specifies the DH group used for key exchange in phase 1.
     */
    dhGroup: string;
    /**
     * Specifies the dead peer detection (DPD) object.
     */
    dpd: outputs.VpnConnectionIkepolicyDpd;
    /**
     * The encryption algorithm, 3DES is less secure, please use them with caution.
     */
    encryptionAlgorithm: string;
    /**
     * The IKE negotiation version.
     */
    ikeVersion: string;
    /**
     * The life cycle of SA in seconds, when the life cycle expires, IKE SA will be automatically updated.
     */
    lifetimeSeconds: number;
    /**
     * The local ID.
     */
    localId: string;
    /**
     * The local ID type.
     */
    localIdType: string;
    /**
     * The peer ID.
     */
    peerId: string;
    /**
     * The peer ID type.
     */
    peerIdType: string;
    /**
     * The DH key group used by PFS.
     */
    pfs: string;
    /**
     * The negotiation mode, only works when the ikeVersion is v1.
     */
    phase1NegotiationMode: string;
}

export interface VpnConnectionIkepolicyDpd {
    /**
     * Specifies the DPD idle timeout period.
     */
    interval: number;
    /**
     * Specifies the format of DPD packets.
     */
    msg: string;
    /**
     * Specifies the interval for retransmitting DPD packets.
     */
    timeout: number;
}

export interface VpnConnectionIpsecpolicy {
    /**
     * The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
     */
    authenticationAlgorithm: string;
    /**
     * The encapsulation mode, only **tunnel** supported for now.
     */
    encapsulationMode: string;
    /**
     * The encryption algorithm, 3DES is less secure, please use them with caution.
     */
    encryptionAlgorithm: string;
    /**
     * The lifecycle time of Ipsec tunnel in seconds.
     */
    lifetimeSeconds: number;
    /**
     * The DH key group used by PFS.
     */
    pfs: string;
    /**
     * The transform protocol. Only **esp** supported for now.
     */
    transformProtocol: string;
}

export interface VpnConnectionPolicyRule {
    /**
     * The list of destination CIDRs.
     */
    destinations: string[];
    /**
     * The rule index.
     */
    ruleIndex: number;
    /**
     * The source CIDR.
     */
    source: string;
}

export interface VpnGatewayCertificate {
    certificateChain: string;
    certificateChainExpireTime: string;
    certificateChainSerialNumber: string;
    certificateChainSubject: string;
    certificateExpireTime: string;
    certificateId: string;
    certificateSerialNumber: string;
    certificateSubject: string;
    content: string;
    createdAt: string;
    encCertificate: string;
    encCertificateExpireTime: string;
    encCertificateSerialNumber: string;
    encCertificateSubject: string;
    encPrivateKey: string;
    issuer: string;
    name: string;
    privateKey: string;
    signatureAlgorithm: string;
    status: string;
    updatedAt: string;
}

export interface VpnGatewayEip1 {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export interface VpnGatewayEip2 {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export interface VpnGatewayMasterEip {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export interface VpnGatewaySlaveEip {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export namespace config {
    export interface AssumeRole {
        agencyName: string;
        domainName: string;
    }

}
